[[beans-factory-scopes]]
= Bean Scopes(한글)

Bean 정의를 생성하면 해당 Bean 정의에 의해 정의된 클래스의 실제 인스턴스를 생성하는 레시피를 생성하게 됩니다.
Bean 정의가 레시피라는 개념이 중요한 이유는 클래스와 마찬가지로 하나의 레시피에서 많은 객체 인스턴스를 생성할 수 있기 때문입니다.

특정 Bean 정의에서 생성되는 객체에 연결될 다양한 종속성과 구성 값을 제어할 수 있을 뿐만 아니라 특정 Bean 정의에서 생성되는 객체의 Scope도 제어할 수 있습니다. 
이 접근 방식은 Java 클래스 수준에서 객체의 Scope를 베이크(bake)할 필요 없이 구성을 통해 생성하는 객체의 Scope를 선택할 수 있기 때문에 강력하고 유연합니다.
Bean은 여러 Scope 중 하나에 배포되도록 정의할 수 있습니다.
Spring 프레임워크는 6개의 스코프를 지원하며, 이 중 4개의 스코프는 web-aware `ApplicationContext` 를 사용하는 경우에만 사용할 수 있습니다. xref:core/beans/factory-scopes.adoc#beans-factory-scopes-custom[사용자 정의 Scope]를 생성할 수도 있습니다.

다음 표는 지원되는 Scope에 대해 설명합니다:

[[beans-factory-scopes-tbl]]
.Bean scopes
[cols="20%,80%"]
|===
| Scope| Description

| xref:core/beans/factory-scopes.adoc#beans-factory-scopes-singleton[singleton]
| (기본값) 각 Spring IoC 컨테이너에 대해 단일 Bean 정의의 Scope를 단일 객체 인스턴스로 지정합니다.

| xref:core/beans/factory-scopes.adoc#beans-factory-scopes-prototype[prototype]
| 단일 Bean 정의의 Scope를 원하는 수의 객체 인스턴스로 지정합니다.

| xref:core/beans/factory-scopes.adoc#beans-factory-scopes-request[request]
| 단일 Bean 정의의 Scope를 단일 HTTP 요청의 라이프사이클로 한정합니다. 즉, 각 HTTP 요청에는 단일 Bean 정의에 기반하여 생성된 Bean의 자체 인스턴스가 있습니다. web-aware Spring `ApplicationContext` 의 컨텍스트에서만 유효합니다.

| xref:core/beans/factory-scopes.adoc#beans-factory-scopes-session[session]
| 단일 Bean 정의를 HTTP `Session` 의 라이프사이클로 Scope를 지정합니다. web-aware Spring `ApplicationContext` 의 컨텍스트에서만 유효합니다.

| xref:core/beans/factory-scopes.adoc#beans-factory-scopes-application[application]
| 단일 Bean 정의를 `ServletContext` 의 라이프사이클로 Scope를 지정합니다. web-aware Spring `ApplicationContext` 의 컨텍스트에서만 유효합니다.

| xref:web/websocket/stomp/scope.adoc[websocket]
| 단일 Bean 정의를 `WebSocket` 의 라이프사이클로 Scope를 지정합니다. web-aware 스프링 `ApplicationContext` 의 컨텍스트에서만 유효합니다.
|===

NOTE: 스레드(thread) Scope를 사용할 수 있지만 기본적으로 등록되어 있지 않습니다.
자세한 내용은 {spring-framework-api}/context/support/SimpleThreadScope.html[`SimpleThreadScope`] 설명서를 참조하세요.
이 스코프 또는 다른 사용자 정의 스코프를 등록하는 방법에 대한 지침은 xref:core/beans/factory-scopes.adoc#beans-factory-scopes-custom-using[사용자 정의 스코프 사용]을 참조하세요.



[[beans-factory-scopes-singleton]]
== 싱글톤 Scope(The Singleton Scope)

싱글톤 Bean의 공유 인스턴스는 하나만 관리되며, 해당 Bean 정의와 일치하는 ID를 가진 Bean에 대한 모든 요청은 Spring 컨테이너에서 해당 특정 Bean 인스턴스 하나를 반환하게 됩니다.

다시 말해, Bean 정의를 정의하고 이것이 싱글톤으로 Scope가 지정되면 Spring IoC 컨테이너는 해당 Bean 정의에 의해 정의된 객체의 인스턴스를 정확히 하나만 생성합니다.
이 단일 인스턴스는 이러한 싱글톤 Bean의 캐시에 저장되며, 이후 해당 이름의 Bean에 대한 모든 요청과 참조는 캐시된 객체를 반환합니다. 다음 이미지는 싱글톤 Scope의 작동 방식을 보여줍니다:

image::singleton.png[]

Spring의 싱글톤 Bean 개념은 GoF(Gang of Four) 패턴 책에 정의된 싱글톤 패턴과 다릅니다.
GoF 싱글톤은 특정 클래스의 인스턴스가 ClassLoader당 하나만 생성되도록 객체의 Scope를 하드코딩합니다.
Spring 싱글톤의 Scope는 컨테이너별 및 Bean별로 설명하는 것이 가장 좋습니다.
즉, 단일 Spring 컨테이너에서 특정 클래스에 대해 하나의 Bean을 정의하면 Spring 컨테이너는 해당 Bean 정의에 의해 정의된 클래스의 인스턴스를 하나만 생성합니다.
싱글톤 Scope는 Spring의 기본 Scope입니다.
XML에서 Bean을 싱글톤으로 정의하려면 다음 예제와 같이 Bean을 정의할 수 있습니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="accountService" class="com.something.DefaultAccountService"/>

	<!-- the following is equivalent, though redundant (singleton scope is the default) -->
	<bean id="accountService" class="com.something.DefaultAccountService" scope="singleton"/>
----



[[beans-factory-scopes-prototype]]
== 프로토타입 Scope(The Prototype Scope)

비싱글톤 프로토타입 Scope의 Bean 배포는 특정 Bean에 대한 요청이 있을 때마다 새로운 Bean 인스턴스를 생성합니다.
즉, Bean이 다른 Bean에 주입되거나 컨테이너에서 `getBean()` 메서드 호출을 통해 요청됩니다.
원칙적으로 모든 상태 저장 Bean에는 프로토타입 스코프를, 상태 비저장 Bean에는 싱글톤 스코프를 사용해야 합니다.

다음 다이어그램은 Spring 프로토타입의 Scope를 보여줍니다:

image::prototype.png[]

(데이터 액세스 객체(DAO)는 일반적으로 프로토타입으로 구성되지 않는데, 이는 일반적인 DAO가 대화 상태를 보유하지 않기 때문입니다. 
싱글톤 다이어그램의 핵심을 재사용하는 것이 더 쉬웠기 때문입니다.)

다음 예제는 XML에서 Bean을 프로토타입으로 정의합니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="accountService" class="com.something.DefaultAccountService" scope="prototype"/>
----

다른 Scope와 달리 Spring은 프로토타입 Bean의 전체 라이프사이클을 관리하지 않습니다.
컨테이너는 프로토타입 객체를 인스턴스화, 구성 및 기타 방식으로 어셈블하여 클라이언트에 전달하며, 해당 프로토타입 인스턴스에 대한 추가 기록은 남기지 않습니다.
따라서 초기화 수명 주기 콜백 메서드는 Scope에 관계없이 모든 객체에서 호출되지만, 프로토타입의 경우 구성된 소멸 수명 주기 콜백은 호출되지 않습니다.
클라이언트 코드는 프로토타입 Scope의 객체를 정리하고 프로토타입 Bean이 보유하고 있는 값비싼 리소스를 해제해야 합니다. 
Spring 컨테이너가 프로토타입 Scope의 Bean이 보유한 리소스를 해제하도록 하려면, 정리해야 하는 Bean에 대한 참조가 있는 사용자 정의 xref:core/beans/factory-extension.adoc#beans-factory-extension-bpp[Bean post-processor]를 사용해보십시오.

어떤 측면에서, 프로토타입 Scope의 Bean에 대한 Spring 컨테이너의 역할은 Java `new` 연산자를 대체하는 것입니다.
그 이후의 모든 라이프사이클 관리는 클라이언트에서 처리해야 합니다. (Spring 컨테이너에서 Bean의 라이프사이클에 대한 자세한 내용은 xref:core/beans/factory-nature.adoc#beans-factory-lifecycle[라이프사이클 콜백]을 참조하십시오).



[[beans-factory-scopes-sing-prot-interaction]]
== 프로토타입-빈 종속성이 있는 싱글톤 Bean(Singleton Beans with Prototype-bean Dependencies)

프로토타입 Bean에 대한 종속성이 있는 싱글톤 Scope Bean을 사용하는 경우, 종속성은 인스턴스화 시점에 확인된다는 점에 유의하세요.
따라서 프로토타입 Scope Bean을 싱글톤 Scope Bean에 종속성을 주입하는 경우 새 프로토타입 Bean이 인스턴스화된 다음 싱글톤 Bean에 종속성이 주입됩니다.
프로토타입 인스턴스는 싱글톤 Scope Bean에 제공되는 유일한 인스턴스입니다.

그러나 런타임에 싱글톤 Scope Bean이 프로토타입 Scope Bean의 새 인스턴스를 반복적으로 획득하기를 원한다고 가정해 보겠습니다.
Spring 컨테이너가 싱글톤 Bean을 인스턴스화하고 해당 종속성을 해결하고 주입할 때 한 번만 발생하기 때문에 프로토타입 Scope Bean을 싱글톤 Bean에 종속성을 주입할 수 없습니다.
런타임에 프로토타입 Bean의 새 인스턴스가 두 번 이상 필요한 경우 xref:core/beans/dependencies/factory-method-injection.adoc[메서드 주입]을 참조하세요.



[[beans-factory-scopes-other]]
== 리퀘스트, 세션, 애플리케이션, 웹소켓 Scope(Request, Session, Application, and WebSocket Scopes)

`request`, `session`, `application`, `websocket` Scope는 web-aware Spring `ApplicationContext` 구현(예: `XmlWebApplicationContext`)을 사용하는 경우에만 사용할 수 있습니다.
이러한 Scope를 `ClassPathXmlApplicationContext` 와 같은 일반 Spring IoC 컨테이너와 함께 사용하는 경우, 알 수 없는 Bean Scope에 대해 발생하는 `IllegalStateException` 이 throw됩니다.



[[beans-factory-scopes-other-web-configuration]]
=== 초기 웹 구성(Initial Web Configuration)

To support the scoping of beans at the `request`, `session`, `application`, and
`websocket` levels (web-scoped beans), some minor initial configuration is
required before you define your beans. (This initial setup is not required
for the standard scopes: `singleton` and `prototype`.)

How you accomplish this initial setup depends on your particular Servlet environment.

If you access scoped beans within Spring Web MVC, in effect, within a request that is
processed by the Spring `DispatcherServlet`, no special setup is necessary.
`DispatcherServlet` already exposes all relevant state.

If you use a Servlet web container, with requests processed outside of Spring's
`DispatcherServlet` (for example, when using JSF), you need to register the
`org.springframework.web.context.request.RequestContextListener` `ServletRequestListener`.
This can be done programmatically by using the `WebApplicationInitializer` interface.
Alternatively, add the following declaration to your web application's `web.xml` file:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<web-app>
		...
		<listener>
			<listener-class>
				org.springframework.web.context.request.RequestContextListener
			</listener-class>
		</listener>
		...
	</web-app>
----

Alternatively, if there are issues with your listener setup, consider using Spring's
`RequestContextFilter`. The filter mapping depends on the surrounding web
application configuration, so you have to change it as appropriate. The following listing
shows the filter part of a web application:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<web-app>
		...
		<filter>
			<filter-name>requestContextFilter</filter-name>
			<filter-class>org.springframework.web.filter.RequestContextFilter</filter-class>
		</filter>
		<filter-mapping>
			<filter-name>requestContextFilter</filter-name>
			<url-pattern>/*</url-pattern>
		</filter-mapping>
		...
	</web-app>
----

`DispatcherServlet`, `RequestContextListener`, and `RequestContextFilter` all do exactly
the same thing, namely bind the HTTP request object to the `Thread` that is servicing
that request. This makes beans that are request- and session-scoped available further
down the call chain.



[[beans-factory-scopes-request]]
=== Request scope

Consider the following XML configuration for a bean definition:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="loginAction" class="com.something.LoginAction" scope="request"/>
----

The Spring container creates a new instance of the `LoginAction` bean by using the
`loginAction` bean definition for each and every HTTP request. That is, the
`loginAction` bean is scoped at the HTTP request level. You can change the internal
state of the instance that is created as much as you want, because other instances
created from the same `loginAction` bean definition do not see these changes in state.
They are particular to an individual request. When the request completes processing, the
bean that is scoped to the request is discarded.

When using annotation-driven components or Java configuration, the `@RequestScope` annotation
can be used to assign a component to the `request` scope. The following example shows how
to do so:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@RequestScope
	@Component
	public class LoginAction {
		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	@RequestScope
	@Component
	class LoginAction {
		// ...
	}
----
======



[[beans-factory-scopes-session]]
=== Session Scope

Consider the following XML configuration for a bean definition:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="userPreferences" class="com.something.UserPreferences" scope="session"/>
----

The Spring container creates a new instance of the `UserPreferences` bean by using the
`userPreferences` bean definition for the lifetime of a single HTTP `Session`. In other
words, the `userPreferences` bean is effectively scoped at the HTTP `Session` level. As
with request-scoped beans, you can change the internal state of the instance that is
created as much as you want, knowing that other HTTP `Session` instances that are also
using instances created from the same `userPreferences` bean definition do not see these
changes in state, because they are particular to an individual HTTP `Session`. When the
HTTP `Session` is eventually discarded, the bean that is scoped to that particular HTTP
`Session` is also discarded.

When using annotation-driven components or Java configuration, you can use the
`@SessionScope` annotation to assign a component to the `session` scope.

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@SessionScope
	@Component
	public class UserPreferences {
		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	@SessionScope
	@Component
	class UserPreferences {
		// ...
	}
----
======



[[beans-factory-scopes-application]]
=== Application Scope

Consider the following XML configuration for a bean definition:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="appPreferences" class="com.something.AppPreferences" scope="application"/>
----

The Spring container creates a new instance of the `AppPreferences` bean by using the
`appPreferences` bean definition once for the entire web application. That is, the
`appPreferences` bean is scoped at the `ServletContext` level and stored as a regular
`ServletContext` attribute. This is somewhat similar to a Spring singleton bean but
differs in two important ways: It is a singleton per `ServletContext`, not per Spring
`ApplicationContext` (for which there may be several in any given web application),
and it is actually exposed and therefore visible as a `ServletContext` attribute.

When using annotation-driven components or Java configuration, you can use the
`@ApplicationScope` annotation to assign a component to the `application` scope. The
following example shows how to do so:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@ApplicationScope
	@Component
	public class AppPreferences {
		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	@ApplicationScope
	@Component
	class AppPreferences {
		// ...
	}
----
======



[[beans-factory-scopes-websocket]]
=== WebSocket Scope

WebSocket scope is associated with the lifecycle of a WebSocket session and applies to
STOMP over WebSocket applications, see
xref:web/websocket/stomp/scope.adoc[WebSocket scope] for more details.



[[beans-factory-scopes-other-injection]]
=== Scoped Beans as Dependencies

The Spring IoC container manages not only the instantiation of your objects (beans),
but also the wiring up of collaborators (or dependencies). If you want to inject (for
example) an HTTP request-scoped bean into another bean of a longer-lived scope, you may
choose to inject an AOP proxy in place of the scoped bean. That is, you need to inject
a proxy object that exposes the same public interface as the scoped object but that can
also retrieve the real target object from the relevant scope (such as an HTTP request)
and delegate method calls onto the real object.

[NOTE]
====
You may also use `<aop:scoped-proxy/>` between beans that are scoped as `singleton`,
with the reference then going through an intermediate proxy that is serializable
and therefore able to re-obtain the target singleton bean on deserialization.

When declaring `<aop:scoped-proxy/>` against a bean of scope `prototype`, every method
call on the shared proxy leads to the creation of a new target instance to which the
call is then being forwarded.

Also, scoped proxies are not the only way to access beans from shorter scopes in a
lifecycle-safe fashion. You may also declare your injection point (that is, the
constructor or setter argument or autowired field) as `ObjectFactory<MyTargetBean>`,
allowing for a `getObject()` call to retrieve the current instance on demand every
time it is needed -- without holding on to the instance or storing it separately.

As an extended variant, you may declare `ObjectProvider<MyTargetBean>` which delivers
several additional access variants, including `getIfAvailable` and `getIfUnique`.

The JSR-330 variant of this is called `Provider` and is used with a `Provider<MyTargetBean>`
declaration and a corresponding `get()` call for every retrieval attempt.
See xref:core/beans/standard-annotations.adoc[here] for more details on JSR-330 overall.
====

The configuration in the following example is only one line, but it is important to
understand the "`why`" as well as the "`how`" behind it:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">

		<!-- an HTTP Session-scoped bean exposed as a proxy -->
		<bean id="userPreferences" class="com.something.UserPreferences" scope="session">
			<!-- instructs the container to proxy the surrounding bean -->
			<aop:scoped-proxy/> <1>
		</bean>

		<!-- a singleton-scoped bean injected with a proxy to the above bean -->
		<bean id="userService" class="com.something.SimpleUserService">
			<!-- a reference to the proxied userPreferences bean -->
			<property name="userPreferences" ref="userPreferences"/>
		</bean>
	</beans>
----
<1> The line that defines the proxy.

To create such a proxy, you insert a child `<aop:scoped-proxy/>` element into a
scoped bean definition (see
xref:core/beans/factory-scopes.adoc#beans-factory-scopes-other-injection-proxies[Choosing the Type of Proxy to Create]
and xref:core/appendix/xsd-schemas.adoc[XML Schema-based configuration]).

Why do definitions of beans scoped at the `request`, `session` and custom-scope
levels require the `<aop:scoped-proxy/>` element in common scenarios?
Consider the following singleton bean definition and contrast it with
what you need to define for the aforementioned scopes (note that the following
`userPreferences` bean definition as it stands is incomplete):

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="userPreferences" class="com.something.UserPreferences" scope="session"/>

	<bean id="userManager" class="com.something.UserManager">
		<property name="userPreferences" ref="userPreferences"/>
	</bean>
----

In the preceding example, the singleton bean (`userManager`) is injected with a reference
to the HTTP `Session`-scoped bean (`userPreferences`). The salient point here is that the
`userManager` bean is a singleton: it is instantiated exactly once per
container, and its dependencies (in this case only one, the `userPreferences` bean) are
also injected only once. This means that the `userManager` bean operates only on the
exact same `userPreferences` object (that is, the one with which it was originally injected).

This is not the behavior you want when injecting a shorter-lived scoped bean into a
longer-lived scoped bean (for example, injecting an HTTP `Session`-scoped collaborating
bean as a dependency into singleton bean). Rather, you need a single `userManager`
object, and, for the lifetime of an HTTP `Session`, you need a `userPreferences` object
that is specific to the HTTP `Session`. Thus, the container creates an object that
exposes the exact same public interface as the `UserPreferences` class (ideally an
object that is a `UserPreferences` instance), which can fetch the real
`UserPreferences` object from the scoping mechanism (HTTP request, `Session`, and so
forth). The container injects this proxy object into the `userManager` bean, which is
unaware that this `UserPreferences` reference is a proxy. In this example, when a
`UserManager` instance invokes a method on the dependency-injected `UserPreferences`
object, it is actually invoking a method on the proxy. The proxy then fetches the real
`UserPreferences` object from (in this case) the HTTP `Session` and delegates the
method invocation onto the retrieved real `UserPreferences` object.

Thus, you need the following (correct and complete) configuration when injecting
`request-` and `session-scoped` beans into collaborating objects, as the following example
shows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="userPreferences" class="com.something.UserPreferences" scope="session">
		<aop:scoped-proxy/>
	</bean>

	<bean id="userManager" class="com.something.UserManager">
		<property name="userPreferences" ref="userPreferences"/>
	</bean>
----

[[beans-factory-scopes-other-injection-proxies]]
==== Choosing the Type of Proxy to Create

By default, when the Spring container creates a proxy for a bean that is marked up with
the `<aop:scoped-proxy/>` element, a CGLIB-based class proxy is created.

[NOTE]
====
CGLIB proxies do not intercept private methods. Attempting to call a private method
on such a proxy will not delegate to the actual scoped target object.
====

Alternatively, you can configure the Spring container to create standard JDK
interface-based proxies for such scoped beans, by specifying `false` for the value of
the `proxy-target-class` attribute of the `<aop:scoped-proxy/>` element. Using JDK
interface-based proxies means that you do not need additional libraries in your
application classpath to affect such proxying. However, it also means that the class of
the scoped bean must implement at least one interface and that all collaborators
into which the scoped bean is injected must reference the bean through one of its
interfaces. The following example shows a proxy based on an interface:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- DefaultUserPreferences implements the UserPreferences interface -->
	<bean id="userPreferences" class="com.stuff.DefaultUserPreferences" scope="session">
		<aop:scoped-proxy proxy-target-class="false"/>
	</bean>

	<bean id="userManager" class="com.stuff.UserManager">
		<property name="userPreferences" ref="userPreferences"/>
	</bean>
----

For more detailed information about choosing class-based or interface-based proxying,
see xref:core/aop/proxying.adoc[Proxying Mechanisms].



[[beans-factory-scopes-injection]]
=== Injecting Request/Session References Directly

As an alternative to factory scopes, a Spring `WebApplicationContext` also supports
the injection of `HttpServletRequest`, `HttpServletResponse`, `HttpSession`,
`WebRequest` and (if JSF is present) `FacesContext` and `ExternalContext` into
Spring-managed beans, simply through type-based autowiring next to regular injection
points for other beans. Spring generally injects proxies for such request and session
objects which has the advantage of working in singleton beans and serializable beans
as well, similar to scoped proxies for factory-scoped beans.



[[beans-factory-scopes-custom]]
== Custom Scopes

The bean scoping mechanism is extensible. You can define your own
scopes or even redefine existing scopes, although the latter is considered bad practice
and you cannot override the built-in `singleton` and `prototype` scopes.


[[beans-factory-scopes-custom-creating]]
=== Creating a Custom Scope

To integrate your custom scopes into the Spring container, you need to implement the
`org.springframework.beans.factory.config.Scope` interface, which is described in this
section. For an idea of how to implement your own scopes, see the `Scope`
implementations that are supplied with the Spring Framework itself and the
{spring-framework-api}/beans/factory/config/Scope.html[`Scope`] javadoc,
which explains the methods you need to implement in more detail.

The `Scope` interface has four methods to get objects from the scope, remove them from
the scope, and let them be destroyed.

The session scope implementation, for example, returns the session-scoped bean (if it
does not exist, the method returns a new instance of the bean, after having bound it to
the session for future reference). The following method returns the object from the
underlying scope:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	Object get(String name, ObjectFactory<?> objectFactory)
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	fun get(name: String, objectFactory: ObjectFactory<*>): Any
----
======

The session scope implementation, for example, removes the session-scoped bean from the
underlying session. The object should be returned, but you can return `null` if the
object with the specified name is not found. The following method removes the object from
the underlying scope:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	Object remove(String name)
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	fun remove(name: String): Any
----
======

The following method registers a callback that the scope should invoke when it is
destroyed or when the specified object in the scope is destroyed:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	void registerDestructionCallback(String name, Runnable destructionCallback)
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	fun registerDestructionCallback(name: String, destructionCallback: Runnable)
----
======

See the {spring-framework-api}/beans/factory/config/Scope.html#registerDestructionCallback[javadoc]
or a Spring scope implementation for more information on destruction callbacks.

The following method obtains the conversation identifier for the underlying scope:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	String getConversationId()
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	fun getConversationId(): String
----
======

This identifier is different for each scope. For a session scoped implementation, this
identifier can be the session identifier.



[[beans-factory-scopes-custom-using]]
=== Using a Custom Scope

After you write and test one or more custom `Scope` implementations, you need to make
the Spring container aware of your new scopes. The following method is the central
method to register a new `Scope` with the Spring container:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	void registerScope(String scopeName, Scope scope);
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	fun registerScope(scopeName: String, scope: Scope)
----
======

This method is declared on the `ConfigurableBeanFactory` interface, which is available
through the `BeanFactory` property on most of the concrete `ApplicationContext`
implementations that ship with Spring.

The first argument to the `registerScope(..)` method is the unique name associated with
a scope. Examples of such names in the Spring container itself are `singleton` and
`prototype`. The second argument to the `registerScope(..)` method is an actual instance
of the custom `Scope` implementation that you wish to register and use.

Suppose that you write your custom `Scope` implementation, and then register it as shown
in the next example.

NOTE: The next example uses `SimpleThreadScope`, which is included with Spring but is not
registered by default. The instructions would be the same for your own custom `Scope`
implementations.

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	Scope threadScope = new SimpleThreadScope();
	beanFactory.registerScope("thread", threadScope);
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	val threadScope = SimpleThreadScope()
	beanFactory.registerScope("thread", threadScope)
----
======

You can then create bean definitions that adhere to the scoping rules of your custom
`Scope`, as follows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="..." class="..." scope="thread">
----

With a custom `Scope` implementation, you are not limited to programmatic registration
of the scope. You can also do the `Scope` registration declaratively, by using the
`CustomScopeConfigurer` class, as the following example shows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">

		<bean class="org.springframework.beans.factory.config.CustomScopeConfigurer">
			<property name="scopes">
				<map>
					<entry key="thread">
						<bean class="org.springframework.context.support.SimpleThreadScope"/>
					</entry>
				</map>
			</property>
		</bean>

		<bean id="thing2" class="x.y.Thing2" scope="thread">
			<property name="name" value="Rick"/>
			<aop:scoped-proxy/>
		</bean>

		<bean id="thing1" class="x.y.Thing1">
			<property name="thing2" ref="thing2"/>
		</bean>

	</beans>
----

NOTE: When you place `<aop:scoped-proxy/>` within a `<bean>` declaration for a
`FactoryBean` implementation, it is the factory bean itself that is scoped, not the object
returned from `getObject()`.





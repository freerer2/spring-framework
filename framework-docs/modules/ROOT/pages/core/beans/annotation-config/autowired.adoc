[[beans-autowired-annotation]]
= Using `@Autowired`(반글)

[NOTE]
====
이 섹션에 포함된 예제에서는 JSR 330의 `@Inject` 어노테이션을 Spring의 `@Autowired` 어노테이션 대신 사용할 수 있습니다. 자세한 내용은 xref:core/beans/standard-annotations.adoc[여기]를 참조하세요.
====

다음 예시와 같이 생성자에 `@Autowired` 어노테이션을 적용할 수 있습니다:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	public class MovieRecommender {

		private final CustomerPreferenceDao customerPreferenceDao;

		@Autowired
		public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
			this.customerPreferenceDao = customerPreferenceDao;
		}

		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	class MovieRecommender @Autowired constructor(
		private val customerPreferenceDao: CustomerPreferenceDao)
----
======

[NOTE]
====
Spring 프레임워크 4.3부터, 대상 Bean이 처음부터 하나의 생성자만 정의하는 경우 이러한 생성자에 대한 `@Autowired` 어노테이션은 더 이상 필요하지 않습니다.
그러나 여러 생성자를 사용할 수 있고 주(primary)/기본(default) 생성자가 없는 경우 컨테이너에 어떤 생성자를 사용할지 지시하기 위해 생성자 중 하나 이상에 `@Autowired` 어노테이션을 추가해야 합니다.
자세한 내용은 xref:core/beans/annotation-config/autowired.adoc#beans-autowired-annotation-constructor-resolution[생성자 해결책]에 대한 설명을 참조하세요.
====

다음 예제에서 볼 수 있듯이 `@Autowired` 어노테이션을 _전통적인_ setter 메서드에 적용할 수도 있습니다:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	public class SimpleMovieLister {

		private MovieFinder movieFinder;

		@Autowired
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}

		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	class SimpleMovieLister {

		@set:Autowired
		lateinit var movieFinder: MovieFinder

		// ...

	}
----
======

다음 예제에서 볼 수 있듯이 임의의 이름과 여러 인수가 있는 메서드에도 어노테이션을 적용할 수 있습니다:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	public class MovieRecommender {

		private MovieCatalog movieCatalog;

		private CustomerPreferenceDao customerPreferenceDao;

		@Autowired
		public void prepare(MovieCatalog movieCatalog,
				CustomerPreferenceDao customerPreferenceDao) {
			this.movieCatalog = movieCatalog;
			this.customerPreferenceDao = customerPreferenceDao;
		}

		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	class MovieRecommender {

		private lateinit var movieCatalog: MovieCatalog

		private lateinit var customerPreferenceDao: CustomerPreferenceDao

		@Autowired
		fun prepare(movieCatalog: MovieCatalog,
					customerPreferenceDao: CustomerPreferenceDao) {
			this.movieCatalog = movieCatalog
			this.customerPreferenceDao = customerPreferenceDao
		}

		// ...
	}
----
======

다음 예시와 같이 필드에도 `@Autowired`를 적용할 수 있으며 생성자와 혼합하여 사용할 수도 있습니다:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	public class MovieRecommender {

		private final CustomerPreferenceDao customerPreferenceDao;

		@Autowired
		private MovieCatalog movieCatalog;

		@Autowired
		public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
			this.customerPreferenceDao = customerPreferenceDao;
		}

		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	class MovieRecommender @Autowired constructor(
		private val customerPreferenceDao: CustomerPreferenceDao) {

		@Autowired
		private lateinit var movieCatalog: MovieCatalog

		// ...
	}
----
======

[TIP]
====
대상 컴포넌트(예: `MovieCatalog` 또는 `CustomerPreferenceDao` )가 `@Autowired` 주석이 달린 주입 지점에 사용하는 유형으로 일관되게 선언되어 있는지 확인하세요.
그렇지 않으면 런타임에 "일치하는 유형을 찾을 수 없음" 오류로 인해 주입이 실패할 수 있습니다.

클래스 경로 검색을 통해 찾은 XML 정의 Bean 또는 컴포넌트 클래스의 경우, 컨테이너는 일반적으로 구체적인 유형을 미리 알고 있습니다.
그러나 `@Bean` 팩토리 메서드의 경우, 선언된 반환 유형이 충분히 표현력이 있는지 확인해야 합니다.
여러 인터페이스를 구현하는 컴포넌트나 구현 유형에 의해 잠재적으로 참조될 수 있는 컴포넌트의 경우, 팩토리 메서드에 가장 구체적인 반환 유형을 선언하는 것을 고려하세요(최소한 Bean을 참조하는 주입 지점에서 요구하는 만큼 구체적이어야 합니다).
====

다음 예제와 같이 해당 유형의 배열을 기대하는 필드 또는 메서드에 `@Autowired` 어노테이션을 추가하여 `ApplicationContext` 에서 특정 유형의 모든 Bean을 제공하도록 Spring에 지시할 수도 있습니다:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	public class MovieRecommender {

		@Autowired
		private MovieCatalog[] movieCatalogs;

		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	class MovieRecommender {

		@Autowired
		private lateinit var movieCatalogs: Array<MovieCatalog>

		// ...
	}
----
======

다음 예에서 볼 수 있듯이 입력된 컬렉션에도 동일하게 적용됩니다:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	public class MovieRecommender {

		private Set<MovieCatalog> movieCatalogs;

		@Autowired
		public void setMovieCatalogs(Set<MovieCatalog> movieCatalogs) {
			this.movieCatalogs = movieCatalogs;
		}

		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	class MovieRecommender {

		@Autowired
		lateinit var movieCatalogs: Set<MovieCatalog>

		// ...
	}
----
======

[[beans-factory-ordered]]
[TIP]
====
배열 또는 목록의 항목이 특정 순서로 정렬되도록 하려면 대상 Bean이 `org.springframework.core.Ordered` 인터페이스를 구현하거나 `@Order` 또는 표준 `@Priority` 어노테이션을 사용할 수 있습니다.
그렇지 않으면 컨테이너에 있는 해당 대상 Bean 정의의 등록 순서를 따릅니다.

대상 클래스 수준과 `@Bean` 메서드에서 `@Order` 어노테이션을 선언할 수 있으며, 개별 Bean 정의(동일한 Bean 클래스를 사용하는 여러 정의의 경우)에 대해 선언할 수도 있습니다.
`@Order` 값은 주입 지점의 우선순위에 영향을 미칠 수 있지만, 종속성 관계와 `@DependsOn` 선언에 의해 결정되는 싱글톤 시작 순서에는 영향을 미치지 않는다는 점에 유의하세요.

메서드에 선언할 수 없기 때문에 `@Bean` 수준에서는 표준 `jakarta.annotation.Priority` 어노테이션을 사용할 수 없다는 점에 유의하세요.
그 의미는 각 유형에 대해 단일 Bean에서 `@Order` 값과 `@Primary` 를 조합하여 모델링할 수 있습니다.
====

Even typed `Map` instances can be autowired as long as the expected key type is `String`.
The map values contain all beans of the expected type, and the keys contain the
corresponding bean names, as the following example shows:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	public class MovieRecommender {

		private Map<String, MovieCatalog> movieCatalogs;

		@Autowired
		public void setMovieCatalogs(Map<String, MovieCatalog> movieCatalogs) {
			this.movieCatalogs = movieCatalogs;
		}

		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	class MovieRecommender {

		@Autowired
		lateinit var movieCatalogs: Map<String, MovieCatalog>

		// ...
	}
----
======

By default, autowiring fails when no matching candidate beans are available for a given
injection point. In the case of a declared array, collection, or map, at least one
matching element is expected.

The default behavior is to treat annotated methods and fields as indicating required
dependencies. You can change this behavior as demonstrated in the following example,
enabling the framework to skip a non-satisfiable injection point through marking it as
non-required (i.e., by setting the `required` attribute in `@Autowired` to `false`):

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	public class SimpleMovieLister {

		private MovieFinder movieFinder;

		@Autowired(required = false)
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}

		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	class SimpleMovieLister {

		@Autowired(required = false)
		var movieFinder: MovieFinder? = null

		// ...
	}
----
======

[NOTE]
====
A non-required method will not be called at all if its dependency (or one of its
dependencies, in case of multiple arguments) is not available. A non-required field will
not get populated at all in such cases, leaving its default value in place.

In other words, setting the `required` attribute to `false` indicates that the
corresponding property is _optional_ for autowiring purposes, and the property will be
ignored if it cannot be autowired. This allows properties to be assigned default values
that can be optionally overridden via dependency injection.
====

[[beans-autowired-annotation-constructor-resolution]]
Injected constructor and factory method arguments are a special case since the `required`
attribute in `@Autowired` has a somewhat different meaning due to Spring's constructor
resolution algorithm that may potentially deal with multiple constructors. Constructor
and factory method arguments are effectively required by default but with a few special
rules in a single-constructor scenario, such as multi-element injection points (arrays,
collections, maps) resolving to empty instances if no matching beans are available. This
allows for a common implementation pattern where all dependencies can be declared in a
unique multi-argument constructor — for example, declared as a single public constructor
without an `@Autowired` annotation.

[NOTE]
====
Only one constructor of any given bean class may declare `@Autowired` with the `required`
attribute set to `true`, indicating _the_ constructor to autowire when used as a Spring
bean. As a consequence, if the `required` attribute is left at its default value `true`,
only a single constructor may be annotated with `@Autowired`. If multiple constructors
declare the annotation, they will all have to declare `required=false` in order to be
considered as candidates for autowiring (analogous to `autowire=constructor` in XML).
The constructor with the greatest number of dependencies that can be satisfied by matching
beans in the Spring container will be chosen. If none of the candidates can be satisfied,
then a primary/default constructor (if present) will be used. Similarly, if a class
declares multiple constructors but none of them is annotated with `@Autowired`, then a
primary/default constructor (if present) will be used. If a class only declares a single
constructor to begin with, it will always be used, even if not annotated. Note that an
annotated constructor does not have to be public.
====

Alternatively, you can express the non-required nature of a particular dependency
through Java 8's `java.util.Optional`, as the following example shows:

[source,java,indent=0,subs="verbatim,quotes"]
----
	public class SimpleMovieLister {

		@Autowired
		public void setMovieFinder(Optional<MovieFinder> movieFinder) {
			...
		}
	}
----

As of Spring Framework 5.0, you can also use a `@Nullable` annotation (of any kind
in any package -- for example, `javax.annotation.Nullable` from JSR-305) or just leverage
Kotlin built-in null-safety support:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	public class SimpleMovieLister {

		@Autowired
		public void setMovieFinder(@Nullable MovieFinder movieFinder) {
			...
		}
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	class SimpleMovieLister {

		@Autowired
		var movieFinder: MovieFinder? = null

		// ...
	}
----
======

You can also use `@Autowired` for interfaces that are well-known resolvable
dependencies: `BeanFactory`, `ApplicationContext`, `Environment`, `ResourceLoader`,
`ApplicationEventPublisher`, and `MessageSource`. These interfaces and their extended
interfaces, such as `ConfigurableApplicationContext` or `ResourcePatternResolver`, are
automatically resolved, with no special setup necessary. The following example autowires
an `ApplicationContext` object:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	public class MovieRecommender {

		@Autowired
		private ApplicationContext context;

		public MovieRecommender() {
		}

		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
class MovieRecommender {

	@Autowired
	lateinit var context: ApplicationContext

	// ...
}
----
======

[NOTE]
====
The `@Autowired`, `@Inject`, `@Value`, and `@Resource` annotations are handled by Spring
`BeanPostProcessor` implementations. This means that you cannot apply these annotations
within your own `BeanPostProcessor` or `BeanFactoryPostProcessor` types (if any).
These types must be 'wired up' explicitly by using XML or a Spring `@Bean` method.
====




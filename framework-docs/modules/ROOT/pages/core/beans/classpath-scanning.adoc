[[beans-classpath-scanning]]
= Classpath Scanning and Managed Components(반글)

이 장의 대부분의 예제에서는 XML을 사용하여 Spring 컨테이너 내에서 각 `BeanDefinition` 을 생성하는 구성 메타데이터를 지정합니다.
이전 섹션(xref:core/beans/annotation-config.adoc[주석 기반 컨테이너 구성])에서는 소스 수준 주석을 통해 많은 구성 메타데이터를 제공하는 방법을 보여줬습니다.
그러나 이러한 예시에서도 "기본" Bean 정의는 XML 파일에 명시적으로 정의되어 있고, 어노테이션은 종속성 주입만 구동합니다.
이 섹션에서는 클래스 경로를 스캔하여 후보 컴포넌트를 암시적으로 감지하는 옵션에 대해 설명합니다.
후보 컴포넌트는 필터 기준과 일치하고 컨테이너에 등록된 해당 Bean 정의가 있는 클래스입니다.
이렇게 하면 XML을 사용하여 Bean 등록을 수행할 필요가 없습니다.
대신 어노테이션(예: `@Component`), AspectJ 유형 표현식 또는 사용자 정의 필터 기준을 사용하여 컨테이너에 등록된 Bean 정의가 있는 클래스를 선택할 수 있습니다.

[NOTE]
====
XML 파일 대신 Java를 사용하여 Bean을 정의할 수 있습니다.
이러한 기능을 사용하는 방법에 대한 예는 `@Configuration`, `@Bean`, `@Import` 및 `@DependsOn` 어노테이션을 참조하세요.
====



[[beans-stereotype-annotations]]
== `@Component` 및 추가 스테레오타입 어노테이션(`@Component` and Further Stereotype Annotations)

`@Repository` 어노테이션은 리포지토리(데이터 액세스 객체 또는 DAO라고도 함)의 역할을 수행하는 모든 클래스에 대한 마커입니다.
이 마커의 용도 중에는 xref:data-access/orm/general.adoc#orm-exception-translation[Exception Translation]에 설명된 대로 예외의 자동 번역이 있습니다.

Spring은 추가적인 스테레오타입 주석을 제공합니다: `@Component`, `@Service`, `@Controller`.
`@Component` 는 Spring이 관리하는 모든 컴포넌트에 대한 일반적인 스테레오타입입니다.
`@Repository`, `@Service`, `@Controller` 는 각각 지속성, 서비스, 프레젠테이션 레이어에서 보다 구체적인 사용 사례를 위한 `@Component`의 전문화입니다.
따라서 컴포넌트 클래스에 `@Component`로 주석을 달 수 있지만, 대신 `@Repository`, `@Service` 또는 `@Controller`로 주석을 달면 도구로 처리하거나 aspects와 연결하는 데 더 적합하게 클래스를 사용할 수 있습니다.
예를 들어, 이러한 스테레오타입 어노테이션은 포인트컷의 이상적인 대상이 됩니다.
`@Repository`, `@Service`, `@Controller`는 Spring 프레임워크의 향후 릴리스에서 추가적인 의미를 가질 수도 있습니다.
따라서 서비스 레이어에 `@Component`와 `@Service` 중 하나를 선택해야 한다면 `@Service` 가 더 나은 선택입니다.
마찬가지로, 앞서 설명한 것처럼 `@Repository` 는 이미 지속성 계층에서 자동 예외 변환을 위한 마커로 지원되고 있습니다.



[[beans-meta-annotations]]
== Using Meta-annotations and Composed Annotations

Spring에서 제공하는 많은 어노테이션을 자신의 코드에서 메타 어노테이션으로 사용할 수 있습니다.
메타 어노테이션은 다른 어노테이션에 적용할 수 있는 어노테이션입니다.
예를 들어, 다음 예제에서 볼 수 있듯이 xref:core/beans/classpath-scanning.adoc#beans-stereotype-annotations[이전]에서 언급한 `@Service` 어노테이션은 `@Component` 로 메타 어노테이션이 되어 있습니다:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Component // <1>
	public @interface Service {

		// ...
	}
----
<1> `@ Component` 는 `@ Service` 를 `@ Component` 와 같은 방식으로 취급하게 합니다.

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	@Target(AnnotationTarget.TYPE)
	@Retention(AnnotationRetention.RUNTIME)
	@MustBeDocumented
	@Component // <1>
	annotation class Service {

		// ...
	}
----
<1> The `@Component` causes `@Service` to be treated in the same way as `@Component`.
======

메타 어노테이션을 결합하여 "`구성된 어노테이션`"을 만들 수도 있습니다.
예를 들어 Spring MVC의 `@RestController` 어노테이션은 `@Controller` 와 `@ResponseBody` 로 구성됩니다.

또한 구성된 어노테이션은 선택적으로 메타 어노테이션에서 어트리뷰트를 다시 선언하여 사용자 정의할 수 있습니다.
이는 메타 어노테이션 속성의 하위 집합만 노출하려는 경우에 특히 유용할 수 있습니다.
예를 들어 Spring의 `@SessionScope` 어노테이션은 범위 이름을 `session`으로 하드코딩하지만 여전히 `proxyMode` 의 사용자 정의는 허용합니다.
다음 목록은 `SessionScope` 어노테이션의 정의를 보여줍니다:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@Target({ElementType.TYPE, ElementType.METHOD})
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Scope(WebApplicationContext.SCOPE_SESSION)
	public @interface SessionScope {

		/**
		 * Alias for {@link Scope#proxyMode}.
		 * <p>Defaults to {@link ScopedProxyMode#TARGET_CLASS}.
		 */
		@AliasFor(annotation = Scope.class)
		ScopedProxyMode proxyMode() default ScopedProxyMode.TARGET_CLASS;

	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	@Target(AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)
	@Retention(AnnotationRetention.RUNTIME)
	@MustBeDocumented
	@Scope(WebApplicationContext.SCOPE_SESSION)
	annotation class SessionScope(
			@get:AliasFor(annotation = Scope::class)
			val proxyMode: ScopedProxyMode = ScopedProxyMode.TARGET_CLASS
	)
----
======

그런 다음 다음과 같이 `proxyMode` 를 선언하지 않고 `@SessionScope` 를 사용할 수 있습니다:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@Service
	@SessionScope
	public class SessionScopedService {
		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	@Service
	@SessionScope
	class SessionScopedService {
		// ...
	}
----
======

다음 예시와 같이 `proxyMode` 의 값을 재정의할 수도 있습니다:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@Service
	@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)
	public class SessionScopedUserService implements UserService {
		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	@Service
	@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)
	class SessionScopedUserService : UserService {
		// ...
	}
----
======

자세한 내용은
{스프링 프레임워크 위키}/Spring-Annotation-Programming-Model[Spring Annotation Programming Model] 위키 페이지를 참조하세요.



[[beans-scanning-autodetection]]
== 클래스 자동 감지 및 Bean 정의 등록하기(Automatically Detecting Classes and Registering Bean Definitions)

Spring은 정형화된 클래스를 자동으로 감지하고 그에 해당하는 `BeanDefinition` 인스턴스를 `ApplicationContext` 에 등록할 수 있습니다.
예를 들어, 다음 두 클래스는 이러한 자동 감지를 사용할 수 있습니다:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@Service
	public class SimpleMovieLister {

		private MovieFinder movieFinder;

		public SimpleMovieLister(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	@Service
	class SimpleMovieLister(private val movieFinder: MovieFinder)
----
======

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@Repository
	public class JpaMovieFinder implements MovieFinder {
		// implementation elided for clarity
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	@Repository
	class JpaMovieFinder : MovieFinder {
		// implementation elided for clarity
	}
----
======


이러한 클래스를 자동 감지하고 해당 Bean을 등록하려면 `@Configuration` 클래스에 `@ComponentScan` 을 추가해야 하며, 여기서 `basePackages` 속성은 두 클래스의 공통 부모 패키지입니다.
(또는 각 클래스의 부모 패키지를 포함하는 쉼표, 세미콜론 또는 공백으로 구분된 목록을 지정할 수 있습니다.)

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@Configuration
	@ComponentScan(basePackages = "org.example")
	public class AppConfig  {
		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	@Configuration
	@ComponentScan(basePackages = ["org.example"])
	class AppConfig  {
		// ...
	}
----
======

NOTE: 간결성을 위해 앞의 예제에서는 어노테이션의 `value` 속성(즉, `@ComponentScan("org.example")` 을 사용했을 수 있습니다.)

다음 대안은 XML을 사용합니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">

		<context:component-scan base-package="org.example"/>

	</beans>
----

TIP: `<context:component-scan>`  을 사용하면 `<context:annotation-config>` 의 기능이 암시적으로 활성화됩니다.
일반적으로 `<context:component-scan>` 을 사용할 때는 `<context:annotation-config>` 요소를 포함할 필요가 없습니다.

[NOTE]
====
클래스 경로 패키지를 검사하려면 클래스 경로에 해당 디렉터리 항목이 있어야 합니다.
Ant로 JAR을 빌드할 때 JAR 작업의 파일 전용 스위치를 활성화하지 않았는지 확인하세요.
또한 일부 환경에서는 보안 정책에 따라 클래스 경로 디렉터리가 노출되지 않을 수 있습니다.
-- 예를 들어 JDK 1.7.0_45 이상의 독립 실행형 앱(매니페스트에서 'Trusted-Library' 설정이 필요함)
-- 스택오버플로우-질문}/19394570/java-jre-7u45-breaks-classloader-getresources 참조).

JDK 9의 모듈 경로(Jigsaw)에서 Spring의 클래스 경로 검색은 일반적으로 예상대로 작동합니다.
그러나 컴포넌트 클래스가 `module-info` 디스크립터에 내보내져 있는지 확인하세요.
Spring이 클래스의 비공개 멤버를 호출할 것으로 예상되는 경우, 해당 클래스가 '열린' 상태인지(즉, `module-info` 설명자에서 `exports` 선언 대신 `opens` 선언을 사용하는지) 확인해야 합니다.
====

또한, component-scan 요소를 사용할 때 `AutowiredAnnotationBeanPostProcessor` 와 `CommonAnnotationBeanPostProcessor` 가 모두 암시적으로 포함됩니다.
즉, 두 구성 요소는 XML로 제공된 Bean 구성 메타데이터 없이도 자동 감지되어 함께 연결됩니다.
NOTE: 값이 `false` 인 `annotation-config` 속성을 포함하면 `AutowiredAnnotationBeanPostProcessor` 및 `CommonAnnotationBeanPostProcessor` 의 등록을 비활성화할 수 있습니다.



[[beans-scanning-filters]]
== 필터를 사용하여 스캔 사용자 지정(Using Filters to Customize Scanning)

기본적으로 `@Component`, `@Repository`, `@Service`, `@Controller`, `@Configuration`으로 주석이 달린 클래스 또는 `@Component`로 주석이 달린 사용자 정의 어노테이션만 감지되는 후보 컴포넌트입니다.
그러나 사용자 정의 필터를 적용하여 이 동작을 수정하고 확장할 수 있습니다.
사용자 정의 필터를 `@ComponentScan` 어노테이션의 `includeFilters` 또는 `excludeFilters` 속성으로 추가합니다(또는 XML 구성에서 `<context:component-scan>` 요소의 `<context:include-filter />` 또는 `<context:exclude-filter />` 하위 요소로 추가합니다).
각 필터 요소에는 `type` 및 `expression` 속성이 필요합니다.
다음 표에서는 필터링 옵션에 대해 설명합니다:

[[beans-scanning-filters-tbl]]
.Filter Types
|===
| Filter Type| Example Expression| Description

| annotation (default)
| `org.example.SomeAnnotation`
| 대상 컴포넌트의 유형 수준에서 _present_ 또는 _meta-present_가 될 어노테이션입니다.

| assignable
| `org.example.SomeClass`
| 대상 컴포넌트가 할당(확장 또는 구현)할 수 있는 클래스(또는 인터페이스)입니다.

| aspectj
| `org.example..*Service+`
| An AspectJ type expression to be matched by the target components.

| regex
| `org\.example\.Default.*`
| A regex expression to be matched by the target components' class names.

| custom
| `org.example.MyTypeFilter`
| A custom implementation of the `org.springframework.core.type.TypeFilter` interface.
|===

The following example shows the configuration ignoring all `@Repository` annotations
and using "`stub`" repositories instead:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@Configuration
	@ComponentScan(basePackages = "org.example",
			includeFilters = @Filter(type = FilterType.REGEX, pattern = ".*Stub.*Repository"),
			excludeFilters = @Filter(Repository.class))
	public class AppConfig {
		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	@Configuration
	@ComponentScan(basePackages = ["org.example"],
			includeFilters = [Filter(type = FilterType.REGEX, pattern = [".*Stub.*Repository"])],
			excludeFilters = [Filter(Repository::class)])
	class AppConfig {
		// ...
	}
----
======

The following listing shows the equivalent XML:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<context:component-scan base-package="org.example">
			<context:include-filter type="regex"
					expression=".*Stub.*Repository"/>
			<context:exclude-filter type="annotation"
					expression="org.springframework.stereotype.Repository"/>
		</context:component-scan>
	</beans>
----

NOTE: You can also disable the default filters by setting `useDefaultFilters=false` on the
annotation or by providing `use-default-filters="false"` as an attribute of the
`<component-scan/>` element. This effectively disables automatic detection of classes
annotated or meta-annotated with `@Component`, `@Repository`, `@Service`, `@Controller`,
`@RestController`, or `@Configuration`.



[[beans-factorybeans-annotations]]
== Defining Bean Metadata within Components

Spring components can also contribute bean definition metadata to the container. You can do
this with the same `@Bean` annotation used to define bean metadata within `@Configuration`
annotated classes. The following example shows how to do so:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@Component
	public class FactoryMethodComponent {

		@Bean
		@Qualifier("public")
		public TestBean publicInstance() {
			return new TestBean("publicInstance");
		}

		public void doWork() {
			// Component method implementation omitted
		}
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	@Component
	class FactoryMethodComponent {

		@Bean
		@Qualifier("public")
		fun publicInstance() = TestBean("publicInstance")

		fun doWork() {
			// Component method implementation omitted
		}
	}
----
======

The preceding class is a Spring component that has application-specific code in its
`doWork()` method. However, it also contributes a bean definition that has a factory
method referring to the method `publicInstance()`. The `@Bean` annotation identifies the
factory method and other bean definition properties, such as a qualifier value through
the `@Qualifier` annotation. Other method-level annotations that can be specified are
`@Scope`, `@Lazy`, and custom qualifier annotations.

TIP: In addition to its role for component initialization, you can also place the `@Lazy`
annotation on injection points marked with `@Autowired` or `@Inject`. In this context,
it leads to the injection of a lazy-resolution proxy. However, such a proxy approach
is rather limited. For sophisticated lazy interactions, in particular in combination
with optional dependencies, we recommend `ObjectProvider<MyTargetBean>` instead.

Autowired fields and methods are supported, as previously discussed, with additional
support for autowiring of `@Bean` methods. The following example shows how to do so:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@Component
	public class FactoryMethodComponent {

		private static int i;

		@Bean
		@Qualifier("public")
		public TestBean publicInstance() {
			return new TestBean("publicInstance");
		}

		// use of a custom qualifier and autowiring of method parameters
		@Bean
		protected TestBean protectedInstance(
				@Qualifier("public") TestBean spouse,
				@Value("#{privateInstance.age}") String country) {
			TestBean tb = new TestBean("protectedInstance", 1);
			tb.setSpouse(spouse);
			tb.setCountry(country);
			return tb;
		}

		@Bean
		private TestBean privateInstance() {
			return new TestBean("privateInstance", i++);
		}

		@Bean
		@RequestScope
		public TestBean requestScopedInstance() {
			return new TestBean("requestScopedInstance", 3);
		}
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	@Component
	class FactoryMethodComponent {

		companion object {
			private var i: Int = 0
		}

		@Bean
		@Qualifier("public")
		fun publicInstance() = TestBean("publicInstance")

		// use of a custom qualifier and autowiring of method parameters
		@Bean
		protected fun protectedInstance(
				@Qualifier("public") spouse: TestBean,
				@Value("#{privateInstance.age}") country: String) = TestBean("protectedInstance", 1).apply {
			this.spouse = spouse
			this.country = country
		}

		@Bean
		private fun privateInstance() = TestBean("privateInstance", i++)

		@Bean
		@RequestScope
		fun requestScopedInstance() = TestBean("requestScopedInstance", 3)
	}
----
======

The example autowires the `String` method parameter `country` to the value of the `age`
property on another bean named `privateInstance`. A Spring Expression Language element
defines the value of the property through the notation `#{ <expression> }`. For `@Value`
annotations, an expression resolver is preconfigured to look for bean names when
resolving expression text.

As of Spring Framework 4.3, you may also declare a factory method parameter of type
`InjectionPoint` (or its more specific subclass: `DependencyDescriptor`) to
access the requesting injection point that triggers the creation of the current bean.
Note that this applies only to the actual creation of bean instances, not to the
injection of existing instances. As a consequence, this feature makes most sense for
beans of prototype scope. For other scopes, the factory method only ever sees the
injection point that triggered the creation of a new bean instance in the given scope
(for example, the dependency that triggered the creation of a lazy singleton bean).
You can use the provided injection point metadata with semantic care in such scenarios.
The following example shows how to use `InjectionPoint`:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@Component
	public class FactoryMethodComponent {

		@Bean @Scope("prototype")
		public TestBean prototypeInstance(InjectionPoint injectionPoint) {
			return new TestBean("prototypeInstance for " + injectionPoint.getMember());
		}
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	@Component
	class FactoryMethodComponent {

		@Bean
		@Scope("prototype")
		fun prototypeInstance(injectionPoint: InjectionPoint) =
				TestBean("prototypeInstance for ${injectionPoint.member}")
	}
----
======

The `@Bean` methods in a regular Spring component are processed differently than their
counterparts inside a Spring `@Configuration` class. The difference is that `@Component`
classes are not enhanced with CGLIB to intercept the invocation of methods and fields.
CGLIB proxying is the means by which invoking methods or fields within `@Bean` methods
in `@Configuration` classes creates bean metadata references to collaborating objects.
Such methods are not invoked with normal Java semantics but rather go through the
container in order to provide the usual lifecycle management and proxying of Spring
beans, even when referring to other beans through programmatic calls to `@Bean` methods.
In contrast, invoking a method or field in a `@Bean` method within a plain `@Component`
class has standard Java semantics, with no special CGLIB processing or other
constraints applying.

[NOTE]
====
You may declare `@Bean` methods as `static`, allowing for them to be called without
creating their containing configuration class as an instance. This makes particular
sense when defining post-processor beans (for example, of type `BeanFactoryPostProcessor`
or `BeanPostProcessor`), since such beans get initialized early in the container
lifecycle and should avoid triggering other parts of the configuration at that point.

Calls to static `@Bean` methods never get intercepted by the container, not even within
`@Configuration` classes (as described earlier in this section), due to technical
limitations: CGLIB subclassing can override only non-static methods. As a consequence,
a direct call to another `@Bean` method has standard Java semantics, resulting
in an independent instance being returned straight from the factory method itself.

The Java language visibility of `@Bean` methods does not have an immediate impact on
the resulting bean definition in Spring's container. You can freely declare your
factory methods as you see fit in non-`@Configuration` classes and also for static
methods anywhere. However, regular `@Bean` methods in `@Configuration` classes need
to be overridable -- that is, they must not be declared as `private` or `final`.

`@Bean` methods are also discovered on base classes of a given component or
configuration class, as well as on Java 8 default methods declared in interfaces
implemented by the component or configuration class. This allows for a lot of
flexibility in composing complex configuration arrangements, with even multiple
inheritance being possible through Java 8 default methods as of Spring 4.2.

Finally, a single class may hold multiple `@Bean` methods for the same
bean, as an arrangement of multiple factory methods to use depending on available
dependencies at runtime. This is the same algorithm as for choosing the "`greediest`"
constructor or factory method in other configuration scenarios: The variant with
the largest number of satisfiable dependencies is picked at construction time,
analogous to how the container selects between multiple `@Autowired` constructors.
====



[[beans-scanning-name-generator]]
== Naming Autodetected Components

When a component is autodetected as part of the scanning process, its bean name is
generated by the `BeanNameGenerator` strategy known to that scanner.

By default, the `AnnotationBeanNameGenerator` is used. For Spring
xref:core/beans/classpath-scanning.adoc#beans-stereotype-annotations[stereotype annotations],
if you supply a name via the annotation's `value` attribute that name will be used as
the name in the corresponding bean definition. This convention also applies when the
following JSR-250 and JSR-330 annotations are used instead of Spring stereotype
annotations: `@jakarta.annotation.ManagedBean`, `@javax.annotation.ManagedBean`,
`@jakarta.inject.Named`, and `@javax.inject.Named`.

As of Spring Framework 6.1, the name of the annotation attribute that is used to specify
the bean name is no longer required to be `value`. Custom stereotype annotations can
declare an attribute with a different name (such as `name`) and annotate that attribute
with `@AliasFor(annotation = Component.class, attribute = "value")`. See the source code
declaration of `ControllerAdvice#name()` for a concrete example.

[WARNING]
====
As of Spring Framework 6.1, support for convention-based stereotype names is deprecated
and will be removed in a future version of the framework. Consequently, custom stereotype
annotations must use `@AliasFor` to declare an explicit alias for the `value` attribute
in `@Component`. See the source code declaration of `Repository#value()` and
`ControllerAdvice#name()` for concrete examples.
====

If an explicit bean name cannot be derived from such an annotation or for any other
detected component (such as those discovered by custom filters), the default bean name
generator returns the uncapitalized non-qualified class name. For example, if the
following component classes were detected, the names would be `myMovieLister` and
`movieFinderImpl`.

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@Service("myMovieLister")
	public class SimpleMovieLister {
		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	@Service("myMovieLister")
	class SimpleMovieLister {
		// ...
	}
----
======

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@Repository
	public class MovieFinderImpl implements MovieFinder {
		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	@Repository
	class MovieFinderImpl : MovieFinder {
		// ...
	}
----
======

If you do not want to rely on the default bean-naming strategy, you can provide a custom
bean-naming strategy. First, implement the
{spring-framework-api}/beans/factory/support/BeanNameGenerator.html[`BeanNameGenerator`]
interface, and be sure to include a default no-arg constructor. Then, provide the fully
qualified class name when configuring the scanner, as the following example annotation
and bean definition show.

TIP: If you run into naming conflicts due to multiple autodetected components having the
same non-qualified class name (i.e., classes with identical names but residing in
different packages), you may need to configure a `BeanNameGenerator` that defaults to the
fully qualified class name for the generated bean name. As of Spring Framework 5.2.3, the
`FullyQualifiedAnnotationBeanNameGenerator` located in package
`org.springframework.context.annotation` can be used for such purposes.

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@Configuration
	@ComponentScan(basePackages = "org.example", nameGenerator = MyNameGenerator.class)
	public class AppConfig {
		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	@Configuration
	@ComponentScan(basePackages = ["org.example"], nameGenerator = MyNameGenerator::class)
	class AppConfig {
		// ...
	}
----
======

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<context:component-scan base-package="org.example"
			name-generator="org.example.MyNameGenerator" />
	</beans>
----

As a general rule, consider specifying the name with the annotation whenever other
components may be making explicit references to it. On the other hand, the
auto-generated names are adequate whenever the container is responsible for wiring.



[[beans-scanning-scope-resolver]]
== Providing a Scope for Autodetected Components

As with Spring-managed components in general, the default and most common scope for
autodetected components is `singleton`. However, sometimes you need a different scope
that can be specified by the `@Scope` annotation. You can provide the name of the
scope within the annotation, as the following example shows:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@Scope("prototype")
	@Repository
	public class MovieFinderImpl implements MovieFinder {
		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	@Scope("prototype")
	@Repository
	class MovieFinderImpl : MovieFinder {
		// ...
	}
----
======

NOTE: `@Scope` annotations are only introspected on the concrete bean class (for annotated
components) or the factory method (for `@Bean` methods). In contrast to XML bean
definitions, there is no notion of bean definition inheritance, and inheritance
hierarchies at the class level are irrelevant for metadata purposes.

For details on web-specific scopes such as "`request`" or "`session`" in a Spring context,
see xref:core/beans/factory-scopes.adoc#beans-factory-scopes-other[Request, Session, Application, and WebSocket Scopes]. As with the pre-built annotations for those scopes,
you may also compose your own scoping annotations by using Spring's meta-annotation
approach: for example, a custom annotation meta-annotated with `@Scope("prototype")`,
possibly also declaring a custom scoped-proxy mode.

NOTE: To provide a custom strategy for scope resolution rather than relying on the
annotation-based approach, you can implement the
{spring-framework-api}/context/annotation/ScopeMetadataResolver.html[`ScopeMetadataResolver`]
interface. Be sure to include a default no-arg constructor. Then you can provide the
fully qualified class name when configuring the scanner, as the following example of both
an annotation and a bean definition shows:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@Configuration
	@ComponentScan(basePackages = "org.example", scopeResolver = MyScopeResolver.class)
	public class AppConfig {
		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	@Configuration
	@ComponentScan(basePackages = ["org.example"], scopeResolver = MyScopeResolver::class)
	class AppConfig {
		// ...
	}
----
======

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<context:component-scan base-package="org.example" scope-resolver="org.example.MyScopeResolver"/>
	</beans>
----

When using certain non-singleton scopes, it may be necessary to generate proxies for the
scoped objects. The reasoning is described in xref:core/beans/factory-scopes.adoc#beans-factory-scopes-other-injection[Scoped Beans as Dependencies].
For this purpose, a scoped-proxy attribute is available on the component-scan
element. The three possible values are: `no`, `interfaces`, and `targetClass`. For example,
the following configuration results in standard JDK dynamic proxies:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@Configuration
	@ComponentScan(basePackages = "org.example", scopedProxy = ScopedProxyMode.INTERFACES)
	public class AppConfig {
		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	@Configuration
	@ComponentScan(basePackages = ["org.example"], scopedProxy = ScopedProxyMode.INTERFACES)
	class AppConfig {
		// ...
	}
----
======

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<context:component-scan base-package="org.example" scoped-proxy="interfaces"/>
	</beans>
----



[[beans-scanning-qualifiers]]
== Providing Qualifier Metadata with Annotations

The `@Qualifier` annotation is discussed in xref:core/beans/annotation-config/autowired-qualifiers.adoc[Fine-tuning Annotation-based Autowiring with Qualifiers].
The examples in that section demonstrate the use of the `@Qualifier` annotation and
custom qualifier annotations to provide fine-grained control when you resolve autowire
candidates. Because those examples were based on XML bean definitions, the qualifier
metadata was provided on the candidate bean definitions by using the `qualifier` or `meta`
child elements of the `bean` element in the XML. When relying upon classpath scanning for
auto-detection of components, you can provide the qualifier metadata with type-level
annotations on the candidate class. The following three examples demonstrate this
technique:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@Component
	@Qualifier("Action")
	public class ActionMovieCatalog implements MovieCatalog {
		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	@Component
	@Qualifier("Action")
	class ActionMovieCatalog : MovieCatalog
----
======

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@Component
	@Genre("Action")
	public class ActionMovieCatalog implements MovieCatalog {
		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	@Component
	@Genre("Action")
	class ActionMovieCatalog : MovieCatalog {
		// ...
	}
----
======

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@Component
	@Offline
	public class CachingMovieCatalog implements MovieCatalog {
		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
@Component
@Offline
class CachingMovieCatalog : MovieCatalog {
	// ...
}
----
======

NOTE: As with most annotation-based alternatives, keep in mind that the annotation metadata is
bound to the class definition itself, while the use of XML allows for multiple beans
of the same type to provide variations in their qualifier metadata, because that
metadata is provided per-instance rather than per-class.





[[beans-factory-extension]]
= Container Extension Points(반글)

일반적으로 애플리케이션 개발자는 `ApplicationContext` 구현 클래스를 서브클래스화할 필요가 없습니다.
대신 특수 통합 인터페이스의 구현을 연결하여 Spring IoC 컨테이너를 확장할 수 있습니다.
다음 몇 섹션에서는 이러한 통합 인터페이스에 대해 설명합니다.



[[beans-factory-extension-bpp]]
== BeanPostProcessor을 사용한 Bean 커스터마이징(Customizing Beans by Using a `BeanPostProcessor`)

`BeanPostProcessor` 인터페이스는 자체 인스턴스화 로직, 의존성 해결 로직 등을 제공하기 위해(또는 컨테이너의 기본값을 재정의하기 위해) 구현할 수 있는 콜백 메서드를 정의합니다.
Spring 컨테이너가 Bean의 인스턴스화, 구성 및 초기화를 마친 후 사용자 정의 로직을 구현하려는 경우 하나 이상의 사용자 정의 `BeanPostProcessor` 구현을 플러그인할 수 있습니다.

여러 개의 `BeanPostProcessor` 인스턴스를 구성할 수 있으며, `order` 속성을 설정하여 이러한 `BeanPostProcessor` 인스턴스가 실행되는 순서를 제어할 수 있습니다.
이 property는 `BeanPostProcessor` 가 `Ordered` 인터페이스를 구현하는 경우에만 설정할 수 있습니다.
자체 `BeanPostProcessor` 를 작성하는 경우 `Ordered` 인터페이스도 구현하는 것을 고려해야 합니다.
자세한 내용은 {spring-framework-api}/beans/factory/config/BeanPostProcessor.html[`BeanPostProcessor`] 및 {spring-framework-api}/core/Ordered.html[`Ordered`] 인터페이스의 javadoc을 참조하세요.
xref:core/beans/factory-extension.adoc#beans-factory-programmatically-registering-beanpostprocessors[`BeanPostProcessor` 인스턴스의 프로그래밍 등록]에 대한 참고 사항도 참조하세요.

[NOTE]
====
`BeanPostProcessor` 인스턴스는 Bean(또는 객체) 인스턴스에서 작동합니다.
즉, Spring IoC 컨테이너가 Bean 인스턴스를 인스턴스화한 다음 `BeanPostProcessor` 인스턴스가 작업을 수행합니다.

`BeanPostProcessor` 인스턴스는 컨테이너별로 Scope가 지정됩니다.
이는 컨테이너 계층 구조를 사용하는 경우에만 관련이 있습니다.
하나의 컨테이너에 `BeanPostProcessor` 를 정의하면 해당 컨테이너에 있는 Bean만 사후 처리합니다.
즉, 두 컨테이너가 동일한 계층에 속해 있더라도 한 컨테이너에 정의된 Bean은 다른 컨테이너에 정의된 `BeanPostProcessor` 에 의해 사후 처리되지 않습니다.

실제 Bean 정의(즉, Bean을 정의하는 블루프린트)를 변경하려면 xref:core/beans/factory-extension.adoc#beans-factory-extension-factory-post-processors[`BeanFactoryPostProcessor` 로 구성 메타데이터 사용자 지정]에 설명된 대로 `BeanFactoryPostProcessor` 를 대신 사용해야 합니다.
====

`org.springframework.beans.factory.config.BeanPostProcessor` 인터페이스는 정확히 두 개의 콜백 메서드로 구성됩니다.
이러한 클래스가 컨테이너에 포스트 프로세서로 등록되면 컨테이너에 의해 생성되는 각 Bean 인스턴스에 대해 포스트 프로세서는 컨테이너 초기화 메서드(예: `InitializingBean.afterPropertiesSet()` 또는 선언된 모든 `init` 메서드)가 호출되기 전과 모든 Bean 초기화 콜백 후에 모두 컨테이너로부터 콜백을 가져옵니다.
포스트 프로세서는 콜백을 완전히 무시하는 것을 포함하여 Bean 인스턴스에 대해 모든 작업을 수행할 수 있습니다.
Bean 사후 프로세서는 일반적으로 콜백 인터페이스를 확인하거나 프록시로 Bean을 래핑할 수 있습니다.
일부 Spring AOP 인프라 클래스는 프록시 래핑 로직을 제공하기 위해 Bean 포스트 프로세서로 구현됩니다.

`ApplicationContext` 는 자동으로 `BeanPostProcessor` 인터페이스를 구현하는 구성 메타데이터에 정의된 모든 빈을 자동으로 감지합니다.
그리고 ApplicationContext` 는 이러한 Bean을 포스트 프로세서(post-processors)로 등록하여 나중에 Bean이 생성될 때 호출할 수 있도록 포스트 프로세서로 등록합니다.
Bean 포스트 프로세서는 컨테이너에 다른 Bean과 동일한 방식으로 컨테이너에 배포할 수 있습니다.

구성 클래스에서 `@Bean` 팩토리 메서드를 사용하여 `BeanPostProcessor` 를 선언할 때 주의하십시오. 구성 클래스에서 팩토리 메서드의 반환 유형은 구현된 클래스 자체 또는 최소한 `org.springframework.beans.factory.config.BeanPostProcessor` 인터페이스여야 합니다. 인터페이스여야 하며, 이는 해당 Bean의 포스트프로세서 특성을 명확하게 나타냅니다.
그렇지 않으면 `ApplicationContext` 가 완전히 생성되기 전에 유형별로 자동 감지할 수 없습니다.
`BeanPostProcessor` 는 다른 Bean의 초기화에 적용하기 위해 조기에 인스턴스화되어야 하므로 초기화해야 하므로 이 초기 유형 감지는 매우 중요합니다.

[[beans-factory-programmatically-registering-beanpostprocessors]]
.프로그래밍 방식으로 `BeanPostProcessor` 인스턴스 등록하기
NOTE: `BeanPostProcessor` 등록을 위해 권장되는 방법은 앞서 설명한 대로 `ApplicationContext` 자동 감지를 이용하는 것이지만, `addBeanPostProcessor` 메서드를 사용하여 `ConfigurableBeanFactory` 에 대해 프로그래밍 방식으로 등록할 수도 있습니다.
이는 등록 전에 조건부 로직을 평가해야 하거나 계층 구조의 컨텍스트 간에 Bean post-processor를 복사해야 할 때 유용할 수 있습니다.
그러나 프로그래밍 방식으로 추가된 `BeanPostProcessor` 인스턴스는 `Ordered` 인터페이스를 따르지 않는다는 점에 유의하세요.
여기서 실행 순서를 결정하는 것은 등록 순서입니다.
또한 프로그래밍 방식으로 등록된 `BeanPostProcessor` 인스턴스는 명시적인 순서에 관계없이 자동 감지를 통해 등록된 인스턴스보다 항상 먼저 처리된다는 점에 유의하세요.

Translated with www.DeepL.com/Translator (free version)

.`BeanPostProcessor` 인스턴스 및 AOP 자동 프록싱
[NOTE]
====
`BeanPostProcessor` 인터페이스를 구현하는 클래스는 특별하며 컨테이너에서 다르게 취급됩니다.
모든 `BeanPostProcessor` 인스턴스와 이들이 직접 참조하는 Bean은 시작 시 `ApplicationContext` 의 특수 시작 단계의 일부로 인스턴스화됩니다.
그 다음, 모든 `BeanPostProcessor` 인스턴스가 정렬된 방식으로 등록되고 컨테이너의 모든 추가 Bean에 적용됩니다.
AOP 자동 프록시는 `BeanPostProcessor` 자체로 구현되기 때문에 `BeanPostProcessor` 인스턴스나 인스턴스가 직접 참조하는 Bean은 자동 프록시를 사용할 수 없으며 따라서 측면이 짜여져 있지 않습니다.

이러한 Bean의 경우 정보 로그 메시지가 표시되어야 합니다: `일부 Bean은 모든 BeanPostProcessor 인터페이스에서 처리할 수 없습니다(예: 자동 프록시에 적합하지 않음)`.

자동 배선 또는 `@Resource` (자동 배선으로 되돌아갈 수 있음)를 사용하여 `BeanPostProcessor` 에 Bean을 연결한 경우 Spring이 유형 일치 종속성 후보를 검색할 때 예기치 않은 Bean에 액세스하여 자동 프록시 또는 다른 종류의 Bean 사후 처리에 부적합하게 만들 수 있습니다.
예를 들어, 필드 또는 설정자 이름이 선언된 Bean의 이름과 직접 일치하지 않고 이름 속성이 사용되지 않는 `@Resource` 로 주석이 달린 종속성이 있는 경우, Spring은 유형별로 일치시키기 위해 다른 Bean에 액세스합니다.
====

The following examples show how to write, register, and use `BeanPostProcessor` instances
in an `ApplicationContext`.


[[beans-factory-extension-bpp-examples-hw]]
=== Example: Hello World, `BeanPostProcessor`-style

이 첫 번째 예제는 기본적인 사용법을 보여줍니다.
이 예는 컨테이너에서 생성될 때 각 Bean의 `toString()` 메서드를 호출하고 결과 문자열을 시스템 콘솔에 인쇄하는 사용자 지정 `BeanPostProcessor` 구현을 보여줍니다.

다음 목록은 사용자 지정 `BeanPostProcessor` 구현 클래스 정의를 보여줍니다:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary",chomp="-packages"]
----
	package scripting;

	import org.springframework.beans.factory.config.BeanPostProcessor;

	public class InstantiationTracingBeanPostProcessor implements BeanPostProcessor {

		// simply return the instantiated bean as-is
		public Object postProcessBeforeInitialization(Object bean, String beanName) {
			return bean; // we could potentially return any object reference here...
		}

		public Object postProcessAfterInitialization(Object bean, String beanName) {
			System.out.println("Bean '" + beanName + "' created : " + bean.toString());
			return bean;
		}
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary",chomp="-packages"]
----
	package scripting

	import org.springframework.beans.factory.config.BeanPostProcessor

	class InstantiationTracingBeanPostProcessor : BeanPostProcessor {

		// simply return the instantiated bean as-is
		override fun postProcessBeforeInitialization(bean: Any, beanName: String): Any? {
			return bean // we could potentially return any object reference here...
		}

		override fun postProcessAfterInitialization(bean: Any, beanName: String): Any? {
			println("Bean '$beanName' created : $bean")
			return bean
		}
	}
----
======

다음 `beans` 요소는 `InstantiationTracingBeanPostProcessor` 를 사용합니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:lang="http://www.springframework.org/schema/lang"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/lang
			https://www.springframework.org/schema/lang/spring-lang.xsd">

		<lang:groovy id="messenger"
				script-source="classpath:org/springframework/scripting/groovy/Messenger.groovy">
			<lang:property name="message" value="Fiona Apple Is Just So Dreamy."/>
		</lang:groovy>

		<!--
		when the above bean (messenger) is instantiated, this custom
		BeanPostProcessor implementation will output the fact to the system console
		-->
		<bean class="scripting.InstantiationTracingBeanPostProcessor"/>

	</beans>
----

Notice how the `InstantiationTracingBeanPostProcessor` is merely defined. It does not
even have a name, and, because it is a bean, it can be dependency-injected as you would any
other bean. (The preceding configuration also defines a bean that is backed by a Groovy
script. The Spring dynamic language support is detailed in the chapter entitled
xref:languages/dynamic.adoc[Dynamic Language Support].)

The following Java application runs the preceding code and configuration:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	import org.springframework.context.ApplicationContext;
	import org.springframework.context.support.ClassPathXmlApplicationContext;
	import org.springframework.scripting.Messenger;

	public final class Boot {

		public static void main(final String[] args) throws Exception {
			ApplicationContext ctx = new ClassPathXmlApplicationContext("scripting/beans.xml");
			Messenger messenger = ctx.getBean("messenger", Messenger.class);
			System.out.println(messenger);
		}

	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
    import org.springframework.beans.factory.getBean

	fun main() {
		val ctx = ClassPathXmlApplicationContext("scripting/beans.xml")
		val messenger = ctx.getBean<Messenger>("messenger")
		println(messenger)
	}
----
======

The output of the preceding application resembles the following:

[literal,subs="verbatim,quotes"]
----
Bean 'messenger' created : org.springframework.scripting.groovy.GroovyMessenger@272961
org.springframework.scripting.groovy.GroovyMessenger@272961
----


[[beans-factory-extension-bpp-examples-aabpp]]
=== Example: The `AutowiredAnnotationBeanPostProcessor`

Using callback interfaces or annotations in conjunction with a custom `BeanPostProcessor`
implementation is a common means of extending the Spring IoC container. An example is
Spring's `AutowiredAnnotationBeanPostProcessor` -- a `BeanPostProcessor` implementation
that ships with the Spring distribution and autowires annotated fields, setter methods,
and arbitrary config methods.



[[beans-factory-extension-factory-postprocessors]]
== Customizing Configuration Metadata with a `BeanFactoryPostProcessor`

The next extension point that we look at is the
`org.springframework.beans.factory.config.BeanFactoryPostProcessor`. The semantics of
this interface are similar to those of the `BeanPostProcessor`, with one major
difference: `BeanFactoryPostProcessor` operates on the bean configuration metadata.
That is, the Spring IoC container lets a `BeanFactoryPostProcessor` read the
configuration metadata and potentially change it _before_ the container instantiates
any beans other than `BeanFactoryPostProcessor` instances.

You can configure multiple `BeanFactoryPostProcessor` instances, and you can control the order in
which these `BeanFactoryPostProcessor` instances run by setting the `order` property.
However, you can only set this property if the `BeanFactoryPostProcessor` implements the
`Ordered` interface. If you write your own `BeanFactoryPostProcessor`, you should
consider implementing the `Ordered` interface, too. See the javadoc of the
{spring-framework-api}/beans/factory/config/BeanFactoryPostProcessor.html[`BeanFactoryPostProcessor`]
and {spring-framework-api}/core/Ordered.html[`Ordered`] interfaces for more details.

[NOTE]
====
If you want to change the actual bean instances (that is, the objects that are created
from the configuration metadata), then you instead need to use a `BeanPostProcessor`
(described earlier in
xref:core/beans/factory-extension.adoc#beans-factory-extension-bpp[Customizing Beans by Using a `BeanPostProcessor`]).
While it is technically possible to work with bean instances within a `BeanFactoryPostProcessor`
(for example, by using `BeanFactory.getBean()`), doing so causes premature bean instantiation,
violating the standard container lifecycle. This may cause negative side effects, such as
bypassing bean post processing.

Also, `BeanFactoryPostProcessor` instances are scoped per-container. This is only relevant
if you use container hierarchies. If you define a `BeanFactoryPostProcessor` in one
container, it is applied only to the bean definitions in that container. Bean definitions
in one container are not post-processed by `BeanFactoryPostProcessor` instances in another
container, even if both containers are part of the same hierarchy.
====

A bean factory post-processor is automatically run when it is declared inside an
`ApplicationContext`, in order to apply changes to the configuration metadata that
define the container. Spring includes a number of predefined bean factory
post-processors, such as `PropertyOverrideConfigurer` and
`PropertySourcesPlaceholderConfigurer`. You can also use a custom `BeanFactoryPostProcessor`
-- for example, to register custom property editors.

An `ApplicationContext` automatically detects any beans that are deployed into it that
implement the `BeanFactoryPostProcessor` interface. It uses these beans as bean factory
post-processors, at the appropriate time. You can deploy these post-processor beans as
you would any other bean.

NOTE: As with ``BeanPostProcessor``s , you typically do not want to configure
``BeanFactoryPostProcessor``s for lazy initialization. If no other bean references a
`Bean(Factory)PostProcessor`, that post-processor will not get instantiated at all.
Thus, marking it for lazy initialization will be ignored, and the
`Bean(Factory)PostProcessor` will be instantiated eagerly even if you set the
`default-lazy-init` attribute to `true` on the declaration of your `<beans />` element.


[[beans-factory-placeholderconfigurer]]
=== Example: The Class Name Substitution `PropertySourcesPlaceholderConfigurer`

You can use the `PropertySourcesPlaceholderConfigurer` to externalize property values
from a bean definition in a separate file by using the standard Java `Properties` format.
Doing so enables the person deploying an application to customize environment-specific
properties, such as database URLs and passwords, without the complexity or risk of
modifying the main XML definition file or files for the container.

Consider the following XML-based configuration metadata fragment, where a `DataSource`
with placeholder values is defined:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">
		<property name="locations" value="classpath:com/something/jdbc.properties"/>
	</bean>

	<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
		<property name="driverClassName" value="${jdbc.driverClassName}"/>
		<property name="url" value="${jdbc.url}"/>
		<property name="username" value="${jdbc.username}"/>
		<property name="password" value="${jdbc.password}"/>
	</bean>
----

The example shows properties configured from an external `Properties` file. At runtime,
a `PropertySourcesPlaceholderConfigurer` is applied to the metadata that replaces some
properties of the DataSource. The values to replace are specified as placeholders of the
form pass:q[`${property-name}`], which follows the Ant and log4j and JSP EL style.

The actual values come from another file in the standard Java `Properties` format:

[literal,subs="verbatim,quotes"]
----
jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root
----

Therefore, the `${jdbc.username}` string is replaced at runtime with the value, 'sa', and
the same applies for other placeholder values that match keys in the properties file.
The `PropertySourcesPlaceholderConfigurer` checks for placeholders in most properties and
attributes of a bean definition. Furthermore, you can customize the placeholder prefix and suffix.

With the `context` namespace introduced in Spring 2.5, you can configure property placeholders
with a dedicated configuration element. You can provide one or more locations as a
comma-separated list in the `location` attribute, as the following example shows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<context:property-placeholder location="classpath:com/something/jdbc.properties"/>
----

The `PropertySourcesPlaceholderConfigurer` not only looks for properties in the `Properties`
file you specify. By default, if it cannot find a property in the specified properties files,
it checks against Spring `Environment` properties and regular Java `System` properties.

[WARNING]
=====
Only one such element should be defined for a given application with the properties
that it needs. Several property placeholders can be configured as long as they have distinct
placeholder syntax (`${...}`).

If you need to modularize the source of properties used for the replacement, you should
not create multiple properties placeholders. Rather, you should create your own
`PropertySourcesPlaceholderConfigurer` bean that gathers the properties to use.
=====

[TIP]
=====
You can use the `PropertySourcesPlaceholderConfigurer` to substitute class names, which
is sometimes useful when you have to pick a particular implementation class at runtime.
The following example shows how to do so:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean class="org.springframework.beans.factory.config.PropertySourcesPlaceholderConfigurer">
		<property name="locations">
			<value>classpath:com/something/strategy.properties</value>
		</property>
		<property name="properties">
			<value>custom.strategy.class=com.something.DefaultStrategy</value>
		</property>
	</bean>

	<bean id="serviceStrategy" class="${custom.strategy.class}"/>
----

If the class cannot be resolved at runtime to a valid class, resolution of the bean
fails when it is about to be created, which is during the `preInstantiateSingletons()`
phase of an `ApplicationContext` for a non-lazy-init bean.
=====


[[beans-factory-overrideconfigurer]]
=== Example: The `PropertyOverrideConfigurer`

The `PropertyOverrideConfigurer`, another bean factory post-processor, resembles the
`PropertySourcesPlaceholderConfigurer`, but unlike the latter, the original definitions
can have default values or no values at all for bean properties. If an overriding
`Properties` file does not have an entry for a certain bean property, the default
context definition is used.

Note that the bean definition is not aware of being overridden, so it is not
immediately obvious from the XML definition file that the override configurer is being
used. In case of multiple `PropertyOverrideConfigurer` instances that define different
values for the same bean property, the last one wins, due to the overriding mechanism.

Properties file configuration lines take the following format:

[literal,subs="verbatim,quotes"]
----
beanName.property=value
----

The following listing shows an example of the format:

[literal,subs="verbatim,quotes"]
----
dataSource.driverClassName=com.mysql.jdbc.Driver
dataSource.url=jdbc:mysql:mydb
----

This example file can be used with a container definition that contains a bean called
`dataSource` that has `driver` and `url` properties.

Compound property names are also supported, as long as every component of the path
except the final property being overridden is already non-null (presumably initialized
by the constructors). In the following example, the `sammy` property of the `bob`
property of the `fred` property of the `tom` bean is set to the scalar value `123`:

[literal,subs="verbatim,quotes"]
----
tom.fred.bob.sammy=123
----


NOTE: Specified override values are always literal values. They are not translated into
bean references. This convention also applies when the original value in the XML bean
definition specifies a bean reference.

With the `context` namespace introduced in Spring 2.5, it is possible to configure
property overriding with a dedicated configuration element, as the following example shows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<context:property-override location="classpath:override.properties"/>
----



[[beans-factory-extension-factorybean]]
== Customizing Instantiation Logic with a `FactoryBean`

You can implement the `org.springframework.beans.factory.FactoryBean` interface for objects that
are themselves factories.

The `FactoryBean` interface is a point of pluggability into the Spring IoC container's
instantiation logic. If you have complex initialization code that is better expressed in
Java as opposed to a (potentially) verbose amount of XML, you can create your own
`FactoryBean`, write the complex initialization inside that class, and then plug your
custom `FactoryBean` into the container.

The `FactoryBean<T>` interface provides three methods:

* `T getObject()`: Returns an instance of the object this factory creates. The
  instance can possibly be shared, depending on whether this factory returns singletons
  or prototypes.
* `boolean isSingleton()`: Returns `true` if this `FactoryBean` returns singletons or
  `false` otherwise. The default implementation of this method returns `true`.
* `Class<?> getObjectType()`: Returns the object type returned by the `getObject()` method
  or `null` if the type is not known in advance.

The `FactoryBean` concept and interface are used in a number of places within the Spring
Framework. More than 50 implementations of the `FactoryBean` interface ship with Spring
itself.

When you need to ask a container for an actual `FactoryBean` instance itself instead of
the bean it produces, prefix the bean's `id` with the ampersand symbol (`&`) when
calling the `getBean()` method of the `ApplicationContext`. So, for a given `FactoryBean`
with an `id` of `myBean`, invoking `getBean("myBean")` on the container returns the
product of the `FactoryBean`, whereas invoking `getBean("&myBean")` returns the
`FactoryBean` instance itself.




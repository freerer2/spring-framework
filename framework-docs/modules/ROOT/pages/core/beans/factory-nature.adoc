[[beans-factory-nature]]
= Customizing the Nature of a Bean(반글)

Spring 프레임워크는 Bean의 특성을 사용자 정의하는 데 사용할 수 있는 다양한 인터페이스를 제공하므로 특성을 사용자 정의하는 데 사용할 수 있는 다양한 인터페이스를 제공합니다.
이 섹션에서는 이러한 인터페이스를 다음과 같이 그룹화합니다:

* xref:core/beans/factory-nature.adoc#beans-factory-lifecycle[Lifecycle Callbacks]
* xref:core/beans/factory-nature.adoc#beans-factory-aware[`ApplicationContextAware` and `BeanNameAware`]
* xref:core/beans/factory-nature.adoc#aware-list[Other `Aware` Interfaces]



[[beans-factory-lifecycle]]
== Lifecycle 콜백(Lifecycle Callbacks)

컨테이너의 Bean 수명 주기 관리와 상호 작용하기 위해 Spring `InitializingBean` 및 `DisposableBean` 인터페이스를 구현할 수 있습니다.
컨테이너는 전자의 경우 `afterPropertiesSet()` 을 호출하고 후자의 경우 `destroy()` 를 호출하여 Bean이 초기화 및 소멸 시 특정 작업을 수행하도록 합니다.

[TIP]
====
JSR-250 `@PostConstruct` 및 `@PreDestroy` 어노테이션은 일반적으로 최신 Spring 애플리케이션에서 수명 주기 콜백을 수신하기 위한 모범 사례로 간주됩니다.
이러한 어노테이션을 사용한다는 것은 Bean이 Spring 전용 인터페이스에 연결되지 않는다는 것을 의미합니다.
자세한 내용은 xref:core/beans/annotation-config/postconstruct-and-predestroy-annotations.adoc[`@PostConstruct` 및 `@PreDestroy` 사용]을 참조하세요.

JSR-250 어노테이션을 사용하지 않으면서도 커플링을 제거하려는 경우 `init-method` 및 `destroy-method` Bean 정의 메타데이터를 고려하세요.
====

내부적으로 Spring 프레임워크는 `BeanPostProcessor` 구현을 사용하여 찾을 수 있는 모든 콜백 인터페이스를 처리하고 적절한 메서드를 호출합니다.
Spring이 기본적으로 제공하지 않는 사용자 정의 기능이나 기타 라이프사이클 동작이 필요한 경우 `BeanPostProcessor` 를 직접 구현할 수 있습니다.
자세한 내용은 xref:core/beans/factory-extension.adoc[컨테이너 확장 포인트]를 참조하세요.

초기화 및 소멸 콜백 외에도 Spring 관리 객체는 컨테이너의 자체 라이프사이클에 따라 해당 객체가 시작 및 종료 프로세스에 참여할 수 있도록 `Lifecycle` 인터페이스를 구현할 수도 있습니다.

라이프사이클 콜백 인터페이스는 이 섹션에서 설명합니다.



[[beans-factory-lifecycle-initializingbean]]
=== 초기화 콜백(Initialization Callbacks)

`org.springframework.beans.factory.InitializingBean` 인터페이스는 컨테이너가 Bean에 필요한 모든 property를 설정한 후 초기화 작업을 수행할 수 있도록 합니다.
`InitializingBean` 인터페이스는 단일 메서드를 지정합니다:

[source,java,indent=0,subs="verbatim,quotes"]
----
	void afterPropertiesSet() throws Exception;
----

`InitializingBean` 인터페이스는 코드를 불필요하게 Spring에 결합하므로 사용하지 않는 것이 좋습니다.
또는 xref:core/beans/annotation-config/postconstruct-and-predestroy-annotations.adoc[`@PostConstruct`] 어노테이션을 사용하거나 POJO 초기화 방법을 지정하는 것이 좋습니다.
XML 기반 구성 메타데이터의 경우, `init-method` 속성을 사용하여 무인수 서명이 없는 메서드의 이름을 지정할 수 있습니다.
Java 구성의 경우, `@Bean` 의 `initMethod` 속성을 사용할 수 있습니다.
xref:core/beans/java/bean-annotation.adoc#beans-java-lifecycle-callbacks[Lifecycle Callbacks 받기]를 참조하세요.
다음 예제를 살펴봅시다:org.springframework.beans.factory.InitializingBean` 인터페이스는 컨테이너가 Bean에 필요한 모든 property를 설정한 후 초기화 작업을 수행할 수 있도록 합니다.
`InitializingBean` 인터페이스는 단일 메서드를 지정합니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/>
----

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	public class ExampleBean {

		public void init() {
			// do some initialization work
		}
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	class ExampleBean {

		fun init() {
			// do some initialization work
		}
	}
----
======

앞의 예는 다음 예(두 개의 목록으로 구성됨)와 거의 동일한 효과를 가져옵니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleInitBean" class="examples.AnotherExampleBean"/>
----

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	public class AnotherExampleBean implements InitializingBean {

		@Override
		public void afterPropertiesSet() {
			// do some initialization work
		}
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	class AnotherExampleBean : InitializingBean {

		override fun afterPropertiesSet() {
			// do some initialization work
		}
	}
----
======

그러나 앞의 두 예제 중 첫 번째 예제에서는 코드를 Spring에 연결하지 않습니다.

[NOTE]
====
일반적으로 `@PostConstruct` 및 초기화 메서드는 컨테이너의 싱글톤 생성 Lock 내에서 실행된다는 점에 유의하세요.
Bean 인스턴스는 `@PostConstruct` 메서드에서 반환된 후에만 완전히 초기화되고 다른 사용자에게 게시할 준비가 된 것으로 간주됩니다.
이러한 개별 초기화 메서드는 구성 상태의 유효성을 검사하고 주어진 구성을 기반으로 일부 데이터 구조를 준비하기 위한 것일 뿐, 외부 Bean 액세스를 통한 추가 작업은 하지 않습니다.
그렇지 않으면 초기화 교착 상태가 발생할 위험이 있습니다.

비용이 많이 드는 초기화 후 활동이 트리거되어야 하는 시나리오의 경우, 예를 들어
비동기 데이터베이스 준비 단계와 같이 비용이 많이 드는 초기화 후 활동을 트리거해야 하는 시나리오의 경우, Bean은 `SmartInitializingSingleton.afterSingletonsInstantiated()` 를 구현하거나 `ApplicationListener<ContextRefreshedEvent>` 를 구현하거나 그에 해당하는 어노테이션 `@EventListener(ContextRefreshedEvent.class)` 를 선언하는 등 컨텍스트 새로고침 이벤트에 의존해야 합니다.
이러한 변형은 모든 일반 싱글톤 초기화 이후에 발생하므로 싱글톤 생성 Lock에서 벗어납니다.

또는 `(Smart)Lifecycle` 인터페이스를 구현하고 자동 시작 메커니즘, 사전 삭제 중지 단계, 잠재적인 중지/재시작 콜백을 포함한 컨테이너의 전체 수명 주기 관리와 통합할 수도 있습니다(아래 참조).
====



[[beans-factory-lifecycle-disposablebean]]
=== Destruction Callbacks

org.springframework.beans.factory.DisposableBean` 인터페이스를 구현하면 Bean이 포함된 컨테이너가 소멸될 때 콜백을 받을 수 있습니다.
`DisposableBean` 인터페이스는 단일 메서드를 지정합니다:

[source,java,indent=0,subs="verbatim,quotes"]
----
	void destroy() throws Exception;
----

`DisposableBean` 콜백 인터페이스는 불필요하게 Spring에 코드를 결합하므로 사용하지 않는 것이 좋습니다.
또는 xref:core/beans/annotation-config/postconstruct-and-predestroy-annotations.adoc[`@PreDestroy`] 어노테이션을 사용하거나 Bean 정의에서 지원하는 일반 메서드를 지정하는 것이 좋습니다.
XML 기반 구성 메타데이터의 경우, `<bean/>` 에서 `destroy-method` 속성을 사용할 수 있습니다.
Java 구성의 경우, `@Bean` 의 `destroyMethod` 속성을 사용할 수 있습니다.
xref:core/beans/java/bean-annotation.adoc#beans-java-lifecycle-callbacks[수명 주기 콜백 받기]를 참조하세요.
다음 정의를 고려하세요:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleDestructionBean" class="examples.ExampleBean" destroy-method="cleanup"/>
----

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	public class ExampleBean {

		public void cleanup() {
			// do some destruction work (like releasing pooled connections)
		}
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	class ExampleBean {

		fun cleanup() {
			// do some destruction work (like releasing pooled connections)
		}
	}
----
======

앞의 정의는 다음 정의와 거의 동일한 효과를 가져옵니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleDestructionBean" class="examples.AnotherExampleBean"/>
----

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	public class AnotherExampleBean implements DisposableBean {

		@Override
		public void destroy() {
			// do some destruction work (like releasing pooled connections)
		}
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	class AnotherExampleBean : DisposableBean {

		override fun destroy() {
			// do some destruction work (like releasing pooled connections)
		}
	}
----
======

그러나 앞의 두 정의 중 첫 번째 정의는 코드를 Spring에 결합하지 않습니다.

Spring은 또한 파괴 메서드의 추론을 지원하여 공개 `close`  또는 `shutdown` 메서드를 감지합니다.
이는 Java 구성 클래스에서 `@Bean` 메서드의 기본 동작이며 `java.lang.AutoCloseable` 또는 `java.io.Closeable` 구현과 자동으로 일치하며, 파괴 로직도 Spring에 결합하지 않습니다.

TIP: XML을 사용한 파괴 메서드 추론의 경우, `<bean>` 요소의 `destroy-method` 속성에 특수 `(inferred)` 값을 할당하여 특정 Bean 정의에 대한 Bean 클래스에서 공용 `close` 또는 `shutdown` 메서드를 자동으로 감지하도록 Spring에 지시할 수 있습니다.
또한 이 특수 `(inferred)` 값을 `<beans>` 요소의 `default-destroy-method` 속성에 설정하여 전체 Bean 정의 집합에 이 동작을 적용할 수도 있습니다(xref:core/beans/factory-nature.adoc#beans-factory-lifecycle-default-init-destroy-methods[기본 초기화 및 삭제 메서드] 참조).

[NOTE]
====
확장된 종료 단계의 경우, `Lifecycle` 인터페이스를 구현하고 싱글톤 Bean의 파괴 메서드가 호출되기 전에 조기 중지 신호를 수신할 수 있습니다.
또한 컨테이너가 이러한 모든 중지 처리가 완료될 때까지 기다렸다가 소멸 메서드로 넘어가는 시간 제한적 중지 단계에 대해 `SmartLifecycle` 을 구현할 수도 있습니다.
====



[[beans-factory-lifecycle-default-init-destroy-methods]]
=== 기본 초기화 및 Destroy 메서드(Default Initialization and Destroy Methods)

Spring 전용 `InitializingBean` 및 `DisposableBean` 콜백 인터페이스를 사용하지 않는 초기화 및 소멸 메서드 콜백을 작성하는 경우 일반적으로 `init()`, `initialize()`, `dispose()` 등과 같은 이름을 가진 메서드를 작성하게 됩니다.
이러한 라이프사이클 콜백 메서드의 이름은 프로젝트 전체에서 표준화되어 모든 개발자가 동일한 메서드 이름을 사용하고 일관성을 보장하는 것이 이상적입니다.

Spring 컨테이너를 구성하여 명명된 초기화를 위해 "`look`"하도록 설정하고 모든 Bean에서 콜백 메서드 이름을 삭제할 수 있습니다.
즉, 애플리케이션 개발자는 애플리케이션 클래스를 작성하고 `init()` 이라는 초기화 콜백을 사용할 수 있으며, 각 Bean 정의에 `init-method="init"` 속성을 구성할 필요 없이 `init()`을 사용할 수 있습니다.
Spring IoC 컨테이너는 Bean이 생성될 때 해당 메서드를 호출합니다(그리고 표준 수명 주기 콜백 계약 xref:core/beans/factory-nature.adoc#beans-factory-lifecycle[앞서 설명한])에 따라).
이 기능은 또한 초기화 및 소멸 메서드 콜백에 대해 일관된 명명 규칙을 적용합니다.

초기화 콜백 메서드의 이름이 `init()` 이고 소멸 콜백 메서드의 이름이 `destroy()` 라고 가정해 보겠습니다.
그러면 클래스는 다음 예제의 클래스와 비슷해집니다:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	public class DefaultBlogService implements BlogService {

		private BlogDao blogDao;

		public void setBlogDao(BlogDao blogDao) {
			this.blogDao = blogDao;
		}

		// this is (unsurprisingly) the initialization callback method
		public void init() {
			if (this.blogDao == null) {
				throw new IllegalStateException("The [blogDao] property must be set.");
			}
		}
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	class DefaultBlogService : BlogService {

		private var blogDao: BlogDao? = null

		// this is (unsurprisingly) the initialization callback method
		fun init() {
			if (blogDao == null) {
				throw IllegalStateException("The [blogDao] property must be set.")
			}
		}
	}
----
======

그런 다음 다음과 유사한 Bean에서 해당 클래스를 사용할 수 있습니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans default-init-method="init">

		<bean id="blogService" class="com.something.DefaultBlogService">
			<property name="blogDao" ref="blogDao" />
		</bean>

	</beans>
----

최상위 `<beans/>` 요소 속성에 `default-init-method` 속성이 있으면 Spring IoC 컨테이너가 Bean 클래스의 `init` 이라는 메서드를 초기화 메서드 콜백으로 인식하게 됩니다.
Bean이 생성되고 어셈블될 때 Bean 클래스에 이러한 메서드가 있으면 적절한 시점에 호출됩니다.

최상위 `<beans/>` 요소의 `default-destroy-method` 속성을 사용하여 이와 유사하게(즉, XML에서) 파괴 메서드 콜백을 구성할 수 있습니다.

기존 Bean 클래스에 이미 규칙과 다르게 명명된 콜백 메서드가 있는 경우, `<bean/>` 자체의 `init-method` 및 `destroy-method` 속성을 사용하여 메서드 이름을 지정하여(즉, XML에서) 기본값을 재정의할 수 있습니다.

Spring 컨테이너는 구성된 초기화 콜백이 모든 종속성과 함께 Bean이 제공된 직후에 호출되도록 보장합니다.
따라서 초기화 콜백은 원시 Bean 참조에서 호출되며, 이는 AOP 인터셉터 등이 아직 Bean에 적용되지 않았음을 의미합니다.
대상 Bean이 먼저 완전히 생성된 다음 해당 인터셉터 체인이 포함된 AOP 프록시(예를 들어)가 적용됩니다.
대상 Bean과 프록시가 별도로 정의된 경우, 코드가 프록시를 우회하여 원시 대상 Bean과 상호 작용할 수도 있습니다.
따라서 인터셉터를 `init` 메서드에 적용하는 것은 일관성이 없는데, 그렇게 하면 대상 Bean의 라이프사이클이 프록시 또는 인터셉터에 결합되고 코드가 원시 대상 Bean과 직접 상호 작용할 때 이상한 의미가 남게 되기 때문입니다. +
(역자설명 : 예를 들면 AOP와 초기화 대상 빈이 별도로 구성 된 경우 대상 빈은 AOP와 상호작용을 하지 않는데, 이 때 AOP와 대상 빈의 init 메서드를 결합하게 된다면 이상한 의미를 가진 코드가 된다는 의미)



[[beans-factory-lifecycle-combined-effects]]
=== 수명 주기 메커니즘 결합(Combining Lifecycle Mechanisms)

Spring 2.5부터는 Bean 라이프사이클 동작을 제어하기 위한 세 가지 옵션이 있습니다: 

* xref:core/beans/factory-nature.adoc#beans-factory-lifecycle-initializingbean[`InitializingBean`] 및 xref:core/beans/factory-nature.adoc#beans-factory-lifecycle-disposablebean[`DisposableBean`] 콜백 인터페이스.
* 사용자 정의 `init()` 및 `destroy()` 메서드
* xref:core/beans/annotation-config/postconstruct-and-predestroy-annotations.adoc[`@PostConstruct` 및 `@PreDestroy` 어노테이션].
이러한 메커니즘을 결합하여 특정 Bean을 제어할 수 있습니다.

NOTE: If multiple lifecycle mechanisms are configured for a bean and each mechanism is
configured with a different method name, then each configured method is run in the
order listed after this note. However, if the same method name is configured -- for example,
`init()` for an initialization method -- for more than one of these lifecycle mechanisms,
that method is run once, as explained in the
xref:core/beans/factory-nature.adoc#beans-factory-lifecycle-default-init-destroy-methods[preceding section].

Multiple lifecycle mechanisms configured for the same bean, with different
initialization methods, are called as follows:

. Methods annotated with `@PostConstruct`
. `afterPropertiesSet()` as defined by the `InitializingBean` callback interface
. A custom configured `init()` method

Destroy methods are called in the same order:

. Methods annotated with `@PreDestroy`
. `destroy()` as defined by the `DisposableBean` callback interface
. A custom configured `destroy()` method



[[beans-factory-lifecycle-processor]]
=== Startup and Shutdown Callbacks

The `Lifecycle` interface defines the essential methods for any object that has its own
lifecycle requirements (such as starting and stopping some background process):

[source,java,indent=0,subs="verbatim,quotes"]
----
	public interface Lifecycle {

		void start();

		void stop();

		boolean isRunning();
	}
----

Any Spring-managed object may implement the `Lifecycle` interface. Then, when the
`ApplicationContext` itself receives start and stop signals (for example, for a stop/restart
scenario at runtime), it cascades those calls to all `Lifecycle` implementations
defined within that context. It does this by delegating to a `LifecycleProcessor`, shown
in the following listing:

[source,java,indent=0,subs="verbatim,quotes"]
----
	public interface LifecycleProcessor extends Lifecycle {

		void onRefresh();

		void onClose();
	}
----

Notice that the `LifecycleProcessor` is itself an extension of the `Lifecycle`
interface. It also adds two other methods for reacting to the context being refreshed
and closed.

[TIP]
====
Note that the regular `org.springframework.context.Lifecycle` interface is a plain
contract for explicit start and stop notifications and does not imply auto-startup
at context refresh time. For fine-grained control over auto-startup and for graceful
stopping of a specific bean (including startup and stop phases), consider implementing
the extended `org.springframework.context.SmartLifecycle` interface instead.

Also, please note that stop notifications are not guaranteed to come before destruction.
On regular shutdown, all `Lifecycle` beans first receive a stop notification before
the general destruction callbacks are being propagated. However, on hot refresh during
a context's lifetime or on stopped refresh attempts, only destroy methods are called.
====

The order of startup and shutdown invocations can be important. If a "`depends-on`"
relationship exists between any two objects, the dependent side starts after its
dependency, and it stops before its dependency. However, at times, the direct
dependencies are unknown. You may only know that objects of a certain type should start
prior to objects of another type. In those cases, the `SmartLifecycle` interface defines
another option, namely the `getPhase()` method as defined on its super-interface,
`Phased`. The following listing shows the definition of the `Phased` interface:

[source,java,indent=0,subs="verbatim,quotes"]
----
	public interface Phased {

		int getPhase();
	}
----

The following listing shows the definition of the `SmartLifecycle` interface:

[source,java,indent=0,subs="verbatim,quotes"]
----
	public interface SmartLifecycle extends Lifecycle, Phased {

		boolean isAutoStartup();

		void stop(Runnable callback);
	}
----

When starting, the objects with the lowest phase start first. When stopping, the
reverse order is followed. Therefore, an object that implements `SmartLifecycle` and
whose `getPhase()` method returns `Integer.MIN_VALUE` would be among the first to start
and the last to stop. At the other end of the spectrum, a phase value of
`Integer.MAX_VALUE` would indicate that the object should be started last and stopped
first (likely because it depends on other processes to be running). When considering the
phase value, it is also important to know that the default phase for any "`normal`"
`Lifecycle` object that does not implement `SmartLifecycle` is `0`. Therefore, any
negative phase value indicates that an object should start before those standard
components (and stop after them). The reverse is true for any positive phase value.

The stop method defined by `SmartLifecycle` accepts a callback. Any
implementation must invoke that callback's `run()` method after that implementation's
shutdown process is complete. That enables asynchronous shutdown where necessary, since
the default implementation of the `LifecycleProcessor` interface,
`DefaultLifecycleProcessor`, waits up to its timeout value for the group of objects
within each phase to invoke that callback. The default per-phase timeout is 30 seconds.
You can override the default lifecycle processor instance by defining a bean named
`lifecycleProcessor` within the context. If you want only to modify the timeout,
defining the following would suffice:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="lifecycleProcessor" class="org.springframework.context.support.DefaultLifecycleProcessor">
		<!-- timeout value in milliseconds -->
		<property name="timeoutPerShutdownPhase" value="10000"/>
	</bean>
----

As mentioned earlier, the `LifecycleProcessor` interface defines callback methods for the
refreshing and closing of the context as well. The latter drives the shutdown
process as if `stop()` had been called explicitly, but it happens when the context is
closing. The 'refresh' callback, on the other hand, enables another feature of
`SmartLifecycle` beans. When the context is refreshed (after all objects have been
instantiated and initialized), that callback is invoked. At that point, the
default lifecycle processor checks the boolean value returned by each
`SmartLifecycle` object's `isAutoStartup()` method. If `true`, that object is
started at that point rather than waiting for an explicit invocation of the context's or
its own `start()` method (unlike the context refresh, the context start does not happen
automatically for a standard context implementation). The `phase` value and any
"`depends-on`" relationships determine the startup order as described earlier.



[[beans-factory-shutdown]]
=== Shutting Down the Spring IoC Container Gracefully in Non-Web Applications

[NOTE]
====
This section applies only to non-web applications. Spring's web-based
`ApplicationContext` implementations already have code in place to gracefully shut down
the Spring IoC container when the relevant web application is shut down.
====

If you use Spring's IoC container in a non-web application environment (for
example, in a rich client desktop environment), register a shutdown hook with the
JVM. Doing so ensures a graceful shutdown and calls the relevant destroy methods on your
singleton beans so that all resources are released. You must still configure
and implement these destroy callbacks correctly.

To register a shutdown hook, call the `registerShutdownHook()` method that is
declared on the `ConfigurableApplicationContext` interface, as the following example shows:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	import org.springframework.context.ConfigurableApplicationContext;
	import org.springframework.context.support.ClassPathXmlApplicationContext;

	public final class Boot {

		public static void main(final String[] args) throws Exception {
			ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");

			// add a shutdown hook for the above context...
			ctx.registerShutdownHook();

			// app runs here...

			// main method exits, hook is called prior to the app shutting down...
		}
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	import org.springframework.context.support.ClassPathXmlApplicationContext

	fun main() {
		val ctx = ClassPathXmlApplicationContext("beans.xml")

		// add a shutdown hook for the above context...
		ctx.registerShutdownHook()

		// app runs here...

		// main method exits, hook is called prior to the app shutting down...
	}
----
======



[[beans-factory-thread-safety]]
=== Thread Safety and Visibility

The Spring core container publishes created singleton instances in a thread-safe manner,
guarding access through a singleton lock and guaranteeing visibility in other threads.

As a consequence, application-provided bean classes do not have to be concerned about the
visibility of their initialization state. Regular configuration fields do not have to be
marked as `volatile` as long as they are only mutated during the initialization phase,
providing visibility guarantees similar to `final` even for setter-based configuration
state that is mutable during that initial phase. If such fields get changed after the
bean creation phase and its subsequent initial publication, they need to be declared as
`volatile` or guarded by a common lock whenever accessed.

Note that concurrent access to such configuration state in singleton bean instances,
e.g. for controller instances or repository instances, is perfectly thread-safe after
such safe initial publication from the container side. This includes common singleton
`FactoryBean` instances which are processed within the general singleton lock as well.

For destruction callbacks, the configuration state remains thread-safe but any runtime
state accumulated between initialization and destruction should be kept in thread-safe
structures (or in `volatile` fields for simple cases) as per common Java guidelines.

Deeper `Lifecycle` integration as shown above involves runtime-mutable state such as
a `runnable` field which will have to be declared as `volatile`. While the common
lifecycle callbacks follow a certain order, e.g. a start callback is guaranteed to
only happen after full initialization and a stop callback only after an initial start,
there is a special case with the common stop before destroy arrangement: It is strongly
recommended that the internal state in any such bean also allows for an immediate
destroy callback without a preceding stop since this may happen during an extraordinary
shutdown after a cancelled bootstrap or in case of a stop timeout caused by another bean.



[[beans-factory-aware]]
== `ApplicationContextAware` and `BeanNameAware`

When an `ApplicationContext` creates an object instance that implements the
`org.springframework.context.ApplicationContextAware` interface, the instance is provided
with a reference to that `ApplicationContext`. The following listing shows the definition
of the `ApplicationContextAware` interface:

[source,java,indent=0,subs="verbatim,quotes"]
----
	public interface ApplicationContextAware {

		void setApplicationContext(ApplicationContext applicationContext) throws BeansException;
	}
----

Thus, beans can programmatically manipulate the `ApplicationContext` that created them,
through the `ApplicationContext` interface or by casting the reference to a known
subclass of this interface (such as `ConfigurableApplicationContext`, which exposes
additional functionality). One use would be the programmatic retrieval of other beans.
Sometimes this capability is useful. However, in general, you should avoid it, because
it couples the code to Spring and does not follow the Inversion of Control style,
where collaborators are provided to beans as properties. Other methods of the
`ApplicationContext` provide access to file resources, publishing application events,
and accessing a `MessageSource`. These additional features are described in
xref:core/beans/context-introduction.adoc[Additional Capabilities of the `ApplicationContext`].

Autowiring is another alternative to obtain a reference to the
`ApplicationContext`. The _traditional_ `constructor` and `byType` autowiring modes
(as described in xref:core/beans/dependencies/factory-autowire.adoc[Autowiring Collaborators]) can provide a dependency of type
`ApplicationContext` for a constructor argument or a setter method parameter,
respectively. For more flexibility, including the ability to autowire fields and
multiple parameter methods, use the annotation-based autowiring features. If you do,
the `ApplicationContext` is autowired into a field, constructor argument, or method
parameter that expects the `ApplicationContext` type if the field, constructor, or
method in question carries the `@Autowired` annotation. For more information, see
xref:core/beans/annotation-config/autowired.adoc[Using `@Autowired`].

When an `ApplicationContext` creates a class that implements the
`org.springframework.beans.factory.BeanNameAware` interface, the class is provided with
a reference to the name defined in its associated object definition. The following listing
shows the definition of the BeanNameAware interface:

[source,java,indent=0,subs="verbatim,quotes"]
----
	public interface BeanNameAware {

		void setBeanName(String name) throws BeansException;
	}
----

The callback is invoked after population of normal bean properties but before an
initialization callback such as `InitializingBean.afterPropertiesSet()` or a custom
init-method.



[[aware-list]]
== Other `Aware` Interfaces

Besides `ApplicationContextAware` and `BeanNameAware` (discussed xref:core/beans/factory-nature.adoc#beans-factory-aware[earlier]),
Spring offers a wide range of `Aware` callback interfaces that let beans indicate to the container
that they require a certain infrastructure dependency. As a general rule, the name indicates the
dependency type. The following table summarizes the most important `Aware` interfaces:

[[beans-factory-nature-aware-list]]
.Aware interfaces
|===
| Name| Injected Dependency| Explained in...

| `ApplicationContextAware`
| Declaring `ApplicationContext`.
| xref:core/beans/factory-nature.adoc#beans-factory-aware[`ApplicationContextAware` and `BeanNameAware`]

| `ApplicationEventPublisherAware`
| Event publisher of the enclosing `ApplicationContext`.
| xref:core/beans/context-introduction.adoc[Additional Capabilities of the `ApplicationContext`]

| `BeanClassLoaderAware`
| Class loader used to load the bean classes.
| xref:core/beans/definition.adoc#beans-factory-class[Instantiating Beans]

| `BeanFactoryAware`
| Declaring `BeanFactory`.
| xref:core/beans/beanfactory.adoc[The `BeanFactory` API]

| `BeanNameAware`
| Name of the declaring bean.
| xref:core/beans/factory-nature.adoc#beans-factory-aware[`ApplicationContextAware` and `BeanNameAware`]

| `LoadTimeWeaverAware`
| Defined weaver for processing class definition at load time.
| xref:core/aop/using-aspectj.adoc#aop-aj-ltw[Load-time Weaving with AspectJ in the Spring Framework]

| `MessageSourceAware`
| Configured strategy for resolving messages (with support for parameterization and
  internationalization).
| xref:core/beans/context-introduction.adoc[Additional Capabilities of the `ApplicationContext`]

| `NotificationPublisherAware`
| Spring JMX notification publisher.
| xref:integration/jmx/notifications.adoc[Notifications]

| `ResourceLoaderAware`
| Configured loader for low-level access to resources.
| xref:web/webflux-webclient/client-builder.adoc#webflux-client-builder-reactor-resources[Resources]

| `ServletConfigAware`
| Current `ServletConfig` the container runs in. Valid only in a web-aware Spring
  `ApplicationContext`.
| xref:web/webmvc.adoc#mvc[Spring MVC]

| `ServletContextAware`
| Current `ServletContext` the container runs in. Valid only in a web-aware Spring
  `ApplicationContext`.
| xref:web/webmvc.adoc#mvc[Spring MVC]
|===

Note again that using these interfaces ties your code to the Spring API and does not
follow the Inversion of Control style. As a result, we recommend them for infrastructure
beans that require programmatic access to the container.



